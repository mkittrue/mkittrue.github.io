{"meta":{"title":"mkitture的博客","subtitle":"疾风知劲草，智者必怀仁","description":"Java   Web前端开发    大数据开发   人工智能","author":"mkitture","url":"http://yoursite.com"},"pages":[{"title":"关于博主","date":"2017-11-18T03:11:15.000Z","updated":"2017-11-18T03:13:37.409Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"目录","date":"2017-11-18T02:57:44.000Z","updated":"2017-11-18T03:07:22.483Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2017-11-18T02:48:32.000Z","updated":"2017-11-18T03:07:32.849Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Attention","slug":"Attention","date":"2018-01-03T15:21:26.000Z","updated":"2018-01-03T15:21:26.249Z","comments":true,"path":"2018/01/03/Attention/","link":"","permalink":"http://yoursite.com/2018/01/03/Attention/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"抱窝的日子","slug":"test","date":"2017-12-30T09:36:16.000Z","updated":"2017-12-30T10:53:16.407Z","comments":true,"path":"2017/12/30/test/","link":"","permalink":"http://yoursite.com/2017/12/30/test/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;果不其然啊，用老妈的话说，一回来就抱窝，奈何下午刚想睡会觉，呵呵，小老板打电话过来了，让我临时赶个东西，真特么无语了，毕业好几年的师兄留下的烂摊子还得收拾，咱的小老板每逢年终项目总结的时候好像特别拿咱当人看","text":"&nbsp;&nbsp;&nbsp;&nbsp;果不其然啊，用老妈的话说，一回来就抱窝，奈何下午刚想睡会觉，呵呵，小老板打电话过来了，让我临时赶个东西，真特么无语了，毕业好几年的师兄留下的烂摊子还得收拾，咱的小老板每逢年终项目总结的时候好像特别拿咱当人看呵呵…明晚就要，好吧，今晚咱就把它扯完吧，不就是扯淡嘛，从上到下，大的带小的扯，小的带一群小的扯。。。一首凉凉送给。。。会。扯。的。大。佬。们。。。也送给正在。。。老去的自己（原来从小就不会微笑，就特么会傻笑） new APlayer({ element: document.getElementById(\"aplayer6\"), narrow: false, autoplay: true, showlrc: 0, music: { title: \"凉凉\", author: \"张碧晨\", url: \"http://ozjh9fb7b.bkt.clouddn.com/%E5%BC%A0%E7%A2%A7%E6%99%A8,%E9%99%88%E5%A5%95%E5%A4%AB,%E5%82%B2%E6%97%A5%E5%85%B6%E6%84%A3%20-%20%E5%87%89%E5%87%89.mp3\", pic: \"\", } });","categories":[{"name":"生活杂感","slug":"生活杂感","permalink":"http://yoursite.com/categories/生活杂感/"}],"tags":[]},{"title":"Jsp","slug":"Jsp","date":"2017-12-11T01:37:05.000Z","updated":"2017-12-28T08:42:49.828Z","comments":true,"path":"2017/12/11/Jsp/","link":"","permalink":"http://yoursite.com/2017/12/11/Jsp/","excerpt":"jsp源代码分为模板数据与元素模板数据就是指代码中的html部分元素指代码中java部分，包括脚本（java代码用&lt;%…%&gt;括起来）以及jsp指令与jsp标签","text":"jsp源代码分为模板数据与元素模板数据就是指代码中的html部分元素指代码中java部分，包括脚本（java代码用&lt;%…%&gt;括起来）以及jsp指令与jsp标签 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;%@ page language=\"java\" import=\"java.util.*\" contentType=\"text/html;charset=utf-8\" %&gt;&lt;%Locale locale=request.getLocale();//获取用户的本地化信息Calendar calendar=Calendar.getInstance(locale);//获取用户所在地的时间int hour=calendar.get(Calendar.HOUR_OF_DAY);//获取小时String greeting =\"\";if(hour&lt;=6)&#123; greeting=\"凌晨了，您该睡觉了，良好的睡眠是美好一天的开始\";&#125;else if(hour&lt;=9)&#123; greeting=\"早上好。早餐应该注意营养。\";&#125;else if(hour&lt;=12)&#123; greeting=\"上午好。工作时注意保护眼睛。\";&#125;else if(hour&lt;=18)&#123; greeting=\"下午好\";&#125;else if(hour&lt;=24)&#123; greeting=\"晚上好，放松一下自己，好好休息，睡觉不要太晚哦\";&#125;else &#123;&#125;%&gt; &lt;%--这是jsp注释，可以添加多行 --%&gt;&gt;&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;欢迎页面&lt;/title&gt; &lt;meta http-equiv=\"pragma\" content=\"no-cache\"&gt; &lt;meta http-equiv=\"cache-control\" content=\"no-cache\"&gt; &lt;meta http-equiv=\"expires\" content=\"0\"&gt; &lt;meta http-equiv=\"keywords\" content=\"keyword1,keyword2,keyword3\"&gt; &lt;meta http-equiv=\"description\" content=\"This is my page\"&gt; &lt;/head&gt; &lt;body&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;&lt;%= hour %&gt;&gt;&lt;/td&gt; &lt;td&gt;&lt;%= greeting %&gt;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"职场进阶","slug":"职场进阶","permalink":"http://yoursite.com/categories/职场进阶/"}],"tags":[]},{"title":"数据结构和算法","slug":"数据结构和算法","date":"2017-12-09T08:37:28.000Z","updated":"2017-12-26T14:05:23.795Z","comments":true,"path":"2017/12/09/数据结构和算法/","link":"","permalink":"http://yoursite.com/2017/12/09/数据结构和算法/","excerpt":"常用的数据结构 数据（Array）数组是一种聚合数据类型，是将具有相同类型的若干变量有序组织在一起的集合，数组可以说是最基本的数据结构，在各编程语言中都有对应，一个数组可以分成多个数组元素，按照数组元素的类型，数组可以分为整型数组/字符型数组等。","text":"常用的数据结构 数据（Array）数组是一种聚合数据类型，是将具有相同类型的若干变量有序组织在一起的集合，数组可以说是最基本的数据结构，在各编程语言中都有对应，一个数组可以分成多个数组元素，按照数组元素的类型，数组可以分为整型数组/字符型数组等。 栈（stack）栈是一种特殊的线性表，其只能在一个表的一个固定端进数据结点的插入和删除操作。栈按照后进先出的原则存储数据，也就是说，先插入的数据将被压入栈底，最后插入的数据在栈顶，读出数据的时候，从栈顶开始逐个读出。栈在汇编语言中，经常用于重要数据的现场保护。 对列（Queue）队列和栈类似，也是一种特殊的线性表，不同的是，队列只允许在表的一端进行插入操作，而在另一端进行删除操作。队列中没有元素时，称为空栈。 链表链表是一种数据元素按照链式存储结构的数据结构，这种存储结构在物理上存在非连续的特点。链表由一系列的数据结构点构成，每个数据点包括数据域和引用域两部分，其中，引用域保存了数据结构总下一个元素存放的地址。链表结构中数据元素的逻辑顺序是通过链表中的引用链次序实现。 树（tree）树是典型的非线性结构，其是包含n个结点的有穷集合K。在树结构中，有且仅有一个根结点，该根结点没有前驱点，在树结构中的其他结点都有且仅有一个前驱结点，而且可以有m个后继结点 图（graph）图是另外一种非线性数据结构，在图结构中，数据结点一般称为顶点，而边是顶点的有序偶对。如果两个顶点之间存在一条边，那么就表示这两个顶点具有相邻关系。 堆（Heap）堆是一种特殊的树形数据结构，我们一般讨论的堆是二叉堆。堆的特点是其根结点的值是所有结点中最小的或者最大的，并且根结点的两个子树也是一个堆结构 散列表（Hash）散列表源自于散列函数（Hash function）,其私下跟是如果在结构中存在关键字和T相等的记录，那么必定在F(T)的存储位置可以找到该记录。 new APlayer({ element: document.getElementById(\"aplayer8\"), narrow: false, autoplay: true, showlrc: 0, music: { title: \"风云\", author: \"屠洪刚\", url: \"http://ozjh9fb7b.bkt.clouddn.com/%E5%B1%A0%E6%B4%AA%E5%88%9A%20-%20%E9%A3%8E%E4%BA%91.mp3\", pic: \"\", } }); 顺序表的结构顺序表就是按照顺序存储的方式存储的线性表，该线性表的结点是按照逻辑一次存放在计算机的一组连续的存储单元。 准备数据（创建符合顺序表结构的数据结构）123456789101112131415static final int MAXLEN=100; //定义顺序表的最大长度class DATA&#123; String key; String name; int age; //结点的关键字 &#125;class SLType&#123; DATA[] ListDATA=new DATA[MAXLEN+1]; int ListLen;&#125; 初始化顺序表所谓的初始化顺序表，首先要创建一个空的顺序表，也就是初始化顺序表 1234void SLInit(SLType SL) //初始化顺序表&#123; SL.ListLen=0;&#125; 计算顺序表的长度1234int SLLength(SLType SL)&#123; return(SL.ListLen);&#125; 插入结点插入结点就是在线性表L的第i个位置上插入一个新的结点1234567891011121314151617181920int SLInsert(SLType SL,int n,DATA data)&#123; int i; if(SL.ListLen&gt;=MAXLEN) //顺序表结点数量已超过最大数量 &#123; System.out.println(\"顺序表已满，无法插入结点\"); return 0; &#125; if(n&lt;1||n&gt;SL.ListLen-1) //插入结点序号不正确 &#123; System.out.println(\"插入元素序号错误，不能插入元素！\"); return 0; &#125; for(i=SL.ListLen;i&gt;=n;i--) &#123; SL.ListData[i+1]=SL.ListData[i]; &#125; SL.ListData[n]=data; //插入结点 SL.ListLen++; //顺序表结点数量加1 return 1&#125; 追加结点可以认为是插入结点的特殊形式，在顺序表的末端插入，其代码如下：12345678910int SLAdd(SLType SL,DATA data) //增加元素到顺序表尾部&#123; if(SL.ListLen&gt;=MAXLEN) //顺序表已满 &#123; System.out.println(\"顺序表已满，无法插入\"); return 0; &#125; SL.ListData[++SL.ListLen]=data; return 1;&#125; 删除结点就是删除线性表中的第i个结点123456789101112131415int SLDelete(SLType SL,int n) //删除顺序表中的数据元素&#123; int i; if(n&lt;1||n&gt;SL.ListLen+1) //删除结点序号不正确 &#123; System.out.println(\"删除结点序号错误，无法删除结点！\"); return 0; //删除不成功，返回0 &#125; for(i=n;i&lt;SL.ListLen;i++) &#123; SL.ListData[i]=SL.ListData[i+1]; &#125; SL.ListLen--; //顺序表元素数量减一 return 1; //成功删除，返回1&#125; 查找结点 按照序号查找结点 123456789DATA SLFindByNum(SLType SL,int n) //根据序号返回元素&#123; if(n&lt;1||n&gt;SL.ListLen+1) //元素序号不正确 &#123; System.out.println(\"结点序号错误，不能返回结点！\"); return null; &#125; return SL.ListData[n];&#125; 按照关键结点查找结点 12345678910int SLFindByNum(SLType SL,int n) //根据序号返回元素&#123; int i; for(i=1;i&lt;=SL.ListLen;i++) &#123; if(SL.ListData[i].key.compareTo(key)==0) //如果找到所需要的结点 &#123; return i; &#125; &#125; 显示所有结点1234567891011//简单地逐个引用结点实现int SLALL(SLType SL)&#123; int i; for(i=1;i&lt;=SL.ListLen;i++) &#123; System.out.println(\"(%s,%s,%d)\\n\",SL.ListData[i].key, SL.ListData[i].name,SL.ListData[i].age); &#125; return 0;&#125; 链表结构典型的链表结构，链表中的每个结点都应该包括如下部分： 数据部分，保存的是该结点的实际数据 地址部分，保存的是下一个结点的地址链表还可以分成以下几类： 单链表：每个结点只包含一个引用 双向链表：每个结点包含两个引用，分别指向上个结点和下个结点 单循环链表：在单链表中，将终端结点的引用域null改为指向表头结点或开始结点即可构成的单循环链表 多重链的循环链表：如果将表中的结点链在多环上，将构成多重链的循环链表 准备数据123456789101112class DATA2&#123; String key; //结点的关键字 String name; int age;&#125;class CLType&#123; DATA2 nodeData=new DATA2(); CLType nextNode;&#125; 追加结点由于一般情况下，链表只有一个头引用head，要在末尾添加结点就需要从头引用head开始逐个检查，知道最后一个结点，追加结点的操作步骤如下： 首先分配内存空间，保存新增的结点 从头引用head开始逐个检查，知道找到最后一个结点(即表尾) 将表尾结点的地点设置为新增结点的地址 将新增的结点的地址部分设置成空地址null，即新增结点称为表尾 1234567891011121314151617181920212223242526CLType CLAddEnd(CLType head,DATA2 nodeData) //追加结点&#123; CLType node,htemp if((node=new CLType())==null) &#123; System.out.println(\"申请内存失败！\"); return null; &#125; else &#123; node.nodeData=nodeData; //保存数据 node.nextNode=null; //设置结点引用为空，即为表尾部 if(head==null) &#123; head=node; return head; &#125; htemp=head; while(htemp.nextNode!=null) //查找链表的末尾 &#123; htemp=htemp.nextNode; &#125; htemp.nextNode=node; return head; &#125;&#125; 插入头结点12345678910111213141516CLType CLAddFirst(CLType head,DATA2 nodeData)&#123; CLType node; if((node=new CLType())==null) &#123; System.out.println(\"申请内存失败！\"); return null; &#125; else' &#123; node.nodeData=nodeData; //保存数据 node.nextNode=head; //指向头引用所指结点 head=node; return head; &#125;&#125; 查找结点通过关键字查找1234567891011121314CLType CLFindNode(CLType head,String key) //查找结点&#123; CLType htemp; htemp=head; while(htemp！=null) &#123; if(htemp.nodeData.key.compareTo(key)==0) &#123; return htemp; &#125; htemp=htemp.nextNode; &#125; return null;&#125; 队列结构在表头进行删除，在表尾进行插入操作，属于线性结构，分为： 顺序队列结构使用一组地址连续的内存单元依次保存队列中的数据，在程序中，可以定义一个指定大小的结构数组作为队列。 链式队列结构即使用链表形式保存队列中值设计的操作方式有：入队列、出队列 准备数据(创建一个队列数据结构)1234567891011static final int QUEUELEN=15;class DATA4&#123; String name; int age;&#125;class SQType&#123; DATA4[] data=new DATA4[QUEUELEN]; int head; int tail; &#125; 初始化队列在使用顺序队列之前，首先要创建一个空的顺序队列，即初始化顺序队列，其操作步骤如下： 按符号常量QUEUELEN指定大小申请一片内存空间，用来保存队列中的数据 设置head=0和tail=0，表示一个空栈。12345678910111213代码SQType SQTypeInit()&#123;SQType q;if((q=new SQType())!=null) &#123; q.head=0; q.tail=0; return q; &#125;else &#123; return null; &#125;&#125; 判断空队列判断空队列即判断一个队列结构是否为空，如果为空则表示队列结构中没有数据，此时可以进行入队列操作，但不可以进行出队列操作。1234567int SQTypeIsEmpty(SQType q)&#123; int temp=0; if(q.head==q.tail) temp=1; return (temp);&#125; 判断满队列1234567int SQTypeFull(SQType q)&#123; int temp=0; if(q.tail==QUEUELEN) temp=1; return (temp);&#125; 清空队列清空队列即清除队列中的所有数据，清空队列的代码示例如下：12345void SQTypeClear(SQType q)&#123; q.head=0; q.tail=0;&#125; 释放空间释放空间即释放队列结构所占用的内存单元，需要使用赋值null操作释放所分配的内存1234567void SQTypeFree(SQType q)&#123; if(q!=null) &#123; q=null; &#125;&#125; 入队列入队列是队列结构的基本操作，主要操作是将数据元素保存到队列结构，入队列的具体操作步骤如下： 首先判断队列顶tail，如果tail等于QUEUELEN，则表示溢出，进行出错处理；否则执行以下操作； 设置tail=tail+1(队列顶引用加1，指向入队列地址) 将入队列元素保存到tail指向的位置123456789101112int InSQType(SQType q,DATA4 data)&#123; if(q.tail==QUEUELEN) &#123; System.out.print(\"队列已满！操作失败\"); return(0); &#125; else &#123; q.data[q.tail++]=data; return(1); &#125;&#125; 出队列从队列顶删除一个数据，操作步骤如下： 判断队列head，如果head等于tail，则表示为空队列，进行出错处理；否则，执行下面的步骤 从队列首部取出队头元素（实际是返回对头元素的引用） 设修改对头head的编号，使其指向后一个元素12345678910111213141516171819202122232425262728 DATA4 OutSQType(SQType q) &#123; if(q.head==q.tail) &#123; System.out.print(\"\\n队列已空！操作失败\"); System.exit(0); &#125; else &#123; return q.data[q.head++]; &#125; return ``` ## 读结点数据从head读出数据```java DATA4 PeekSQType(SQType q) &#123; if(SQTypeIsEmpity(q)==1) &#123; System.out.print(\"\\n空队列\"); return null; &#125; else &#123; return q.data[q.head]; &#125; &#125; 计算队列的长度即计算队列长度即统计该队列中数据结点的个数123456int SQTypeLen(SQType q)&#123; int temp; temp=q.tail-q.head; return (temp);&#125; 树结构现实中很多问题都无法抽象为线性数据结构，属于非线性结构。 树结构的基本特征： 在一个数结构中，有且仅有一个节点没有直接前驱，这个结点就是树的前驱结点 除根结点外，其余每个结点有且仅有一个直接前驱 每个结点可以有任意多个直接后继树结构的基本概念 父结点和子结点 兄弟结点 结点的度：一个结点所包含子树的数量 树的度：是指该树所有结点中最大的度 叶结点：树中度为零的结点称为叶结点或终端结点 分支结点：树中度不为零的结点称为分支结点或非终端结点 结点层数：结点的层数从树根开始，根结点为第1层、依次向下为第2、3.。。 树的深度：树中结点的最大层数称为树的深度 有序树：若树中各结点树是按一定的次序从左至右排列的，称为有序树 无序树：若树中各结点的子树（兄弟结点）未按一定次序排列，称为无序树 森林：n(n&gt;0)棵互补相交的树 二叉树二叉树是最简单的一种形式，处理相对简单，更为重要的是，任意的树都可以转换成对应的二叉树特点： 每个结点最多只能有两个子结点 两个结点对应的子树分别称为左子树和右子树 二叉树结点的最大度为2 二叉树进一步分为满二叉树和完全二叉树满二叉树即在二叉树中除最下层的叶结点外，每层的结点都有两个子结点；完全二叉树即最后一层结点树并未能达到最大个数，且最后一层叶结点按照从左向右的顺序连续存在，只缺最后一层右侧若干结点 完全二叉树的顺序存储顺序存储结构是最基本的数据存储方式，与线性表类似，树结构的顺序一般采用一维数组来表示12static final MAXLen=100;char[] SeqBinTree=new char[MAXLen]; 完全二叉树的性质若树中含有n个结点，假设这些结点的按照顺序方式存储，那么对任意一个结点m来说，具有以下性质： 如果m!=1，则结点m的父结点的编号为m/2 如果2m&lt;n，则结点m的左子树根结点的编号为2m;若2*m&gt;n，则无左子树，也没有右子树； 如果2m+1&lt;n，则结点m的右子树根结点编号为2m+1;若2*m+1&gt;n，则无右子树 对于完全二叉树而言，则结点m的右子树根节点编号为[log2n]+1 二叉树的链式存储1234567class ChainTreeType&#123; char NodeData; //元素数据 ChainTree LSonNode; //左子树结点引用 ChainTree RSonNode; //右子树结点引用&#125;ChainTree root=null; //定义二叉树根结点的引用 带父结点的二叉树引用 1234567891011121314151617181920 class ChainTreeType &#123; char NodeData; ChainTreeType LSonNode; ChainTreeType RSonNode; Chain ParentNode; &#125; ChainTreeType root=null;``` ## 准备数据（创建一个二叉树数据结构）```java static final int MAXLEN=20; class CBTType &#123; String data; CBTtype left; CBTtype right; &#125; 初始二叉树1234567891011121314151617181920CBType InitTree()&#123; CBTType node; if((node=new CBTType())!=null) &#123; System.out.printf(\"请输入一个根结点数据：\\n\"); node.data=input.next(); node.left=null; node.right=null; if(node!=null) &#123; return node; &#125; else &#123; return null; &#125; &#125; return null;&#125; 添加结点即在二叉树中添加结点数据，添加结点时除了要输入结点数据外，还需要指定其父结点，以及添加添加的结点是作为左子树和右子树，其代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465 void AddTreeNode(CBTType treeNode) &#123; CBTType pnode,parent; String data; int menusel; if((pnode=new CBTType())!=null) &#123; System.out.printf(\"请输入二叉树结点数据：\\n\"); pnode.data=input.next(); pnode.left=null; pnode.right=null; System.out.printf(\"请输入该结点的父结点的数据：\"); data=input.next(); parent=TreeFindNode(treeNode,data); if(parent==null) &#123; System.out.printf(\"未找到该父结点\"); pnode=null; return; &#125; System.out.printf(\"1.添加该结点到左子树\\n2.添加到该结点到右子树\\n\"); do &#123; menusel=input.nextInt(); if(menusel==1||menusel==2) &#123; if(parent==null) &#123; System.out.printf(\"不存在父结点，请先设置父结点！\\n\"); &#125; else &#123; switch(menusel) &#123; case 1: if(parent.left!=null) &#123; System.out.printf(\"左子树结点为空\\n\"); &#125; else &#123; parent.left=pnode; &#125; break; case 2: if(parent.right!=null) &#123; System.out.printf(\"右子树结点不为空\\n\"); &#125; else &#123; parent.right=pnode; &#125; break; default; System.out.printf(\"无效参数：\\n\"); &#125; &#125; &#125; &#125;while(menusel!=1&amp;&amp;menusel!=2) &#125;&#125; 查找结点123456789101112131415161718192021222324252627282930CBTType TreeFindNode(CBTType treeNode,String data)&#123; CBTType ptr; if(treeNode==null) &#123; return null; &#125; else &#123; if(treeNode.data.equals(data)) &#123; return treeNode; &#125; else &#123; if((ptr=TreeFindNode(treeNode.left,data))!=null) &#123; return ptr; &#125; else if(ptr=TreeFindNode(treeNode.right,data)!=null) &#123; return ptr; &#125; else &#123; return null; &#125; &#125; &#125;&#125; 获取左子树获取左子树即返回当前结点的左子树结点的值，由于在二叉树结构中定义了相应的引用，因此，该操作比较简单。1234567891011CBTType TreeLeftNode(CBTType treeNode)&#123; if(treeNode!=null) &#123; return treeNode.left; &#125; else &#123; return null; &#125;&#125; 获取右子树获取左子树即返回当前结点的左子树结点的值，由于在二叉树结构中定义了相应的引用，因此，该操作比较简单。1234567891011CBTType TreeRightNode(CBTType treeNode)&#123; if(treeNode!=null) &#123; return treeNode.right; &#125; else &#123; return null; &#125;&#125; 判断空树判断空树即判断一个二叉树结构是否为空，如果是空树，则表示该二叉树结构中没有数据，判断空树的代码示例如下：123456789101112131415161718192021222324252627282930313233343536 int TreeIsEmpty(CBTType treeNode) &#123; if(treeNode!=null) &#123; return 0; &#125; else &#123; return 1; &#125; &#125;``` ## 计算二叉树的深度```java int TreeDepth(CBTType treeNode) &#123; int depleft,depright; if(treeNode==null) &#123; return 0; &#125; else &#123; depleft=TreeDepth(treeNode.left); depright=TreeDepth(treeNode.right); if(depleft&gt;depright) &#123; return depleft+1; &#125; else &#123; return depright+1; &#125; &#125; &#125; 清空二叉树清空二叉树即将二叉树变成一颗空树，这里仍需要递归算法实现123456789void ClearTree(CBTType treeNode)&#123; if(treeNode!=null) &#123; ClearTree(treeNode.left); ClearTree(treeNode.right); treeNode=null; &#125;&#125; 显示结点数据1234void TreeNodeData(CBTType p)&#123; System.out.printf(&quot;%s&quot;,p.data);&#125; 遍历二叉树遍历二叉树即逐个查找二叉树中的所有结点，这是二叉树的基本操作，因此很多操作都需要首先遍历整个二叉树，由于二叉树结构的特殊性，往往可以包含多种方法： 先序遍历：即先访问根结点，再按先序遍历左子树，最后按先序遍历右子树，先序遍历一般也称为先根次序遍历，简称为DLR遍历。 中序遍历：即先按照中序遍历左子树，再访问根结点，最后按中序遍历右子树，中序遍历一般也成为中根次序遍历，简称LDR遍历 后续遍历：即先按后序遍历左子树，再按后序遍历右子树，最后访问根接点，后序遍历也称后根次序遍历，简称LRD遍历。 按层遍历算法首先处理第一层的结点即根结点，然后处理第一层结点所在的左右子树即所谓的第二结点代码示例如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344 void LevelTree(CBTType treeNode) &#123; CBTType p; CBTType[] q=new CBTType[MAXLEN]; int head=0,tail=0; if(treeNode!=null) &#123; tail=(tail+1)%MAXLEN; q[tail]=treeNode; &#125; while(head!=tail) &#123; head=(head+1)%MAXLEN; p=q[head]; TreeNodeData(p); if(p.left!=null) &#123; tail=(tail+1)%MAXLEN; q[tail]=p.left; &#125; if(p.right!=null) &#123; tail=(tail+1)%MAXLEN; q[tail]=p.right; &#125; &#125; &#125;``` ### 先序遍历算法```java void DLRTree(CBTType treeNode) &#123; if(treeNode!=null) &#123; TreeNodeData(treeNode); DLRTree(treeNode.left); DLRTree(treeNode.right); &#125; &#125; 中序遍历算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960 void LDRTree(CBTType treeNode) &#123; if(treeNode!=null) &#123; LDRTree(treeNode.left); TreeNodeData(treeNode); LDRTree(treeNode.right); &#125; &#125;``` ### 中序遍历算法```java void LDRTree(CBTType treeNode) &#123; if(treeNode!=null) &#123; LDRTree(treeNode.left); TreeNodeData(treeNode); LDRTree(treeNode.right); &#125; &#125; ``` ### 后序遍历算法```java void LRDTree(CBTType treeNode) &#123; if(treeNode!=null) &#123; LRDTree(treeNode.left); LRDTree(treeNode.right); TreeNodeData(treeNode); &#125; &#125;``` 在表头进行删除，在表尾进行插入操作，属于线性结构，分为： 1. 顺序队列结构 使用一组地址连续的内存单元依次保存队列中的数据，在程序中，可以定义一个指定大小的结构数组作为队列。 2. 链式队列结构 即使用链表形式保存队列中值设计的操作方式有：入队列、出队列## 准备数据(创建一个队列数据结构)```java static final int QUEUELEN=15; class DATA4&#123; String name; int age; &#125; class SQType&#123; DATA4[] data=new DATA4[QUEUELEN]; int head; int tail; &#125; 初始化队列在使用顺序队列之前，首先要创建一个空的顺序队列，即初始化顺序队列，其操作步骤如下： 按符号常量QUEUELEN指定大小申请一片内存空间，用来保存队列中的数据 设置head=0和tail=0，表示一个空栈。12345678910111213SQType SQTypeInit()&#123;SQType q;if((q=new SQType())!=null) &#123; q.head=0; q.tail=0; return q; &#125;else &#123; return null; &#125;&#125; 判断空队列判断空队列即判断一个队列结构是否为空，如果为空则表示队列结构中没有数据，此时可以进行入队列操作，但不可以进行出队列操作。1234567int SQTypeIsEmpty(SQType q)&#123; int temp=0; if(q.head==q.tail) temp=1; return (temp);&#125; 判断满队列1234567int SQTypeFull(SQType q)&#123; int temp=0; if(q.tail==QUEUELEN) temp=1; return (temp);&#125; 清空队列清空队列即清除队列中的所有数据，清空队列的代码示例如下：12345void SQTypeClear(SQType q)&#123; q.head=0; q.tail=0;&#125; 释放空间释放空间即释放队列结构所占用的内存单元，需要使用赋值null操作释放所分配的内存1234567void SQTypeFree(SQType q)&#123; if(q!=null) &#123; q=null; &#125;&#125; 入队列入队列是队列结构的基本操作，主要操作是将数据元素保存到队列结构，入队列的具体操作步骤如下： 首先判断队列顶tail，如果tail等于QUEUELEN，则表示溢出，进行出错处理；否则执行以下操作； 设置tail=tail+1(队列顶引用加1，指向入队列地址) 将入队列元素保存到tail指向的位置123456789101112int InSQType(SQType q,DATA4 data)&#123; if(q.tail==QUEUELEN) &#123; System.out.print(\"队列已满！操作失败\"); return(0); &#125; else &#123; q.data[q.tail++]=data; return(1); &#125;&#125; 出队列从队列顶删除一个数据，操作步骤如下： 判断队列head，如果head等于tail，则表示为空队列，进行出错处理；否则，执行下面的步骤 从队列首部取出队头元素（实际是返回对头元素的引用） 设修改对头head的编号，使其指向后一个元素12345678910111213141516171819202122232425262728 DATA4 OutSQType(SQType q) &#123; if(q.head==q.tail) &#123; System.out.print(\"\\n队列已空！操作失败\"); System.exit(0); &#125; else &#123; return q.data[q.head++]; &#125; return ``` ## 读结点数据从head读出数据```java DATA4 PeekSQType(SQType q) &#123; if(SQTypeIsEmpity(q)==1) &#123; System.out.print(\"\\n空队列\"); return null; &#125; else &#123; return q.data[q.head]; &#125; &#125; 计算队列的长度即计算队列长度即统计该队列中数据结点的个数123456int SQTypeLen(SQType q)&#123; int temp; temp=q.tail-q.head; return (temp);&#125; 树结构现实中很多问题都无法抽象为线性数据结构，属于非线性结构。 树结构的基本特征： 在一个数结构中，有且仅有一个节点没有直接前驱，这个结点就是树的前驱结点 除根结点外，其余每个结点有且仅有一个直接前驱 每个结点可以有任意多个直接后继树结构的基本概念 父结点和子结点 兄弟结点 结点的度：一个结点所包含子树的数量 树的度：是指该树所有结点中最大的度 叶结点：树中度为零的结点称为叶结点或终端结点 分支结点：树中度不为零的结点称为分支结点或非终端结点 结点层数：结点的层数从树根开始，根结点为第1层、依次向下为第2、3.。。 树的深度：树中结点的最大层数称为树的深度 有序树：若树中各结点树是按一定的次序从左至右排列的，称为有序树 无序树：若树中各结点的子树（兄弟结点）未按一定次序排列，称为无序树 森林：n(n&gt;0)棵互补相交的树 二叉树二叉树是最简单的一种形式，处理相对简单，更为重要的是，任意的树都可以转换成对应的二叉树特点： 每个结点最多只能有两个子结点 两个结点对应的子树分别称为左子树和右子树 二叉树结点的最大度为2 二叉树进一步分为满二叉树和完全二叉树满二叉树即在二叉树中除最下层的叶结点外，每层的结点都有两个子结点；完全二叉树即最后一层结点树并未能达到最大个数，且最后一层叶结点按照从左向右的顺序连续存在，只缺最后一层右侧若干结点 完全二叉树的顺序存储顺序存储结构是最基本的数据存储方式，与线性表类似，树结构的顺序一般采用一维数组来表示12static final MAXLen=100;char[] SeqBinTree=new char[MAXLen]; 完全二叉树的性质若树中含有n个结点，假设这些结点的按照顺序方式存储，那么对任意一个结点m来说，具有以下性质： 如果m!=1，则结点m的父结点的编号为m/2 如果2m&lt;n，则结点m的左子树根结点的编号为2m;若2*m&gt;n，则无左子树，也没有右子树； 如果2m+1&lt;n，则结点m的右子树根结点编号为2m+1;若2*m+1&gt;n，则无右子树 对于完全二叉树而言，则结点m的右子树根节点编号为[log2n]+1 二叉树的链式存储1234567class ChainTreeType&#123; char NodeData; //元素数据 ChainTree LSonNode; //左子树结点引用 ChainTree RSonNode; //右子树结点引用&#125;ChainTree root=null; //定义二叉树根结点的引用 带父结点的二叉树引用 12345678class ChainTreeType&#123; char NodeData; ChainTreeType LSonNode; ChainTreeType RSonNode; Chain ParentNode;&#125;ChainTreeType root=null; 准备数据（创建一个二叉树数据结构）1234567static final int MAXLEN=20;class CBTType&#123; String data; CBTtype left; CBTtype right;&#125; 初始二叉树1234567891011121314151617181920CBType InitTree()&#123; CBTType node; if((node=new CBTType())!=null) &#123; System.out.printf(\"请输入一个根结点数据：\\n\"); node.data=input.next(); node.left=null; node.right=null; if(node!=null) &#123; return node; &#125; else &#123; return null; &#125; &#125; return null;&#125; 添加结点即在二叉树中添加结点数据，添加结点时除了要输入结点数据外，还需要指定其父结点，以及添加添加的结点是作为左子树和右子树，其代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465 void AddTreeNode(CBTType treeNode) &#123; CBTType pnode,parent; String data; int menusel; if((pnode=new CBTType())!=null) &#123; System.out.printf(\"请输入二叉树结点数据：\\n\"); pnode.data=input.next(); pnode.left=null; pnode.right=null; System.out.printf(\"请输入该结点的父结点的数据：\"); data=input.next(); parent=TreeFindNode(treeNode,data); if(parent==null) &#123; System.out.printf(\"未找到该父结点\"); pnode=null; return; &#125; System.out.printf(\"1.添加该结点到左子树\\n2.添加到该结点到右子树\\n\"); do &#123; menusel=input.nextInt(); if(menusel==1||menusel==2) &#123; if(parent==null) &#123; System.out.printf(\"不存在父结点，请先设置父结点！\\n\"); &#125; else &#123; switch(menusel) &#123; case 1: if(parent.left!=null) &#123; System.out.printf(\"左子树结点为空\\n\"); &#125; else &#123; parent.left=pnode; &#125; break; case 2: if(parent.right!=null) &#123; System.out.printf(\"右子树结点不为空\\n\"); &#125; else &#123; parent.right=pnode; &#125; break; default; System.out.printf(\"无效参数：\\n\"); &#125; &#125; &#125; &#125;while(menusel!=1&amp;&amp;menusel!=2) &#125;&#125; 查找结点123456789101112131415161718192021222324252627282930CBTType TreeFindNode(CBTType treeNode,String data)&#123; CBTType ptr; if(treeNode==null) &#123; return null; &#125; else &#123; if(treeNode.data.equals(data)) &#123; return treeNode; &#125; else &#123; if((ptr=TreeFindNode(treeNode.left,data))!=null) &#123; return ptr; &#125; else if(ptr=TreeFindNode(treeNode.right,data)!=null) &#123; return ptr; &#125; else &#123; return null; &#125; &#125; &#125;&#125; 获取左子树获取左子树即返回当前结点的左子树结点的值，由于在二叉树结构中定义了相应的引用，因此，该操作比较简单。1234567891011CBTType TreeLeftNode(CBTType treeNode)&#123; if(treeNode!=null) &#123; return treeNode.left; &#125; else &#123; return null; &#125;&#125; 获取右子树获取左子树即返回当前结点的左子树结点的值，由于在二叉树结构中定义了相应的引用，因此，该操作比较简单。1234567891011CBTType TreeRightNode(CBTType treeNode)&#123; if(treeNode!=null) &#123; return treeNode.right; &#125; else &#123; return null; &#125;&#125; 判断空树判断空树即判断一个二叉树结构是否为空，如果是空树，则表示该二叉树结构中没有数据，判断空树的代码示例如下：1234567891011int TreeIsEmpty(CBTType treeNode)&#123; if(treeNode!=null) &#123; return 0; &#125; else &#123; return 1; &#125;&#125; 计算二叉树的深度12345678910111213141516171819202122int TreeDepth(CBTType treeNode)&#123; int depleft,depright; if(treeNode==null) &#123; return 0; &#125; else &#123; depleft=TreeDepth(treeNode.left); depright=TreeDepth(treeNode.right); if(depleft&gt;depright) &#123; return depleft+1; &#125; else &#123; return depright+1; &#125; &#125;&#125; 清空二叉树清空二叉树即将二叉树变成一颗空树，这里仍需要递归算法实现123456789void ClearTree(CBTType treeNode)&#123; if(treeNode!=null) &#123; ClearTree(treeNode.left); ClearTree(treeNode.right); treeNode=null; &#125;&#125; 显示结点数据1234void TreeNodeData(CBTType p)&#123; System.out.printf(\"%s\",p.data);&#125; 遍历二叉树遍历二叉树即逐个查找二叉树中的所有结点，这是二叉树的基本操作，因此很多操作都需要首先遍历整个二叉树，由于二叉树结构的特殊性，往往可以包含多种方法： 先序遍历：即先访问根结点，再按先序遍历左子树，最后按先序遍历右子树，先序遍历一般也称为先根次序遍历，简称为DLR遍历。 中序遍历：即先按照中序遍历左子树，再访问根结点，最后按中序遍历右子树，中序遍历一般也成为中根次序遍历，简称LDR遍历 后续遍历：即先按后序遍历左子树，再按后序遍历右子树，最后访问根接点，后序遍历也称后根次序遍历，简称LRD遍历。 按层遍历算法首先处理第一层的结点即根结点，然后处理第一层结点所在的左右子树即所谓的第二结点代码示例如下：1234567891011121314151617181920212223242526272829void LevelTree(CBTType treeNode)&#123; CBTType p; CBTType[] q=new CBTType[MAXLEN]; int head=0,tail=0; if(treeNode!=null) &#123; tail=(tail+1)%MAXLEN; q[tail]=treeNode; &#125; while(head!=tail) &#123; head=(head+1)%MAXLEN; p=q[head]; TreeNodeData(p); if(p.left!=null) &#123; tail=(tail+1)%MAXLEN; q[tail]=p.left; &#125; if(p.right!=null) &#123; tail=(tail+1)%MAXLEN; q[tail]=p.right; &#125; &#125;&#125; 先序遍历算法12345678910void DLRTree(CBTType treeNode)&#123; if(treeNode!=null) &#123; TreeNodeData(treeNode); DLRTree(treeNode.left); DLRTree(treeNode.right); &#125;&#125; 中序遍历算法123456789void LDRTree(CBTType treeNode)&#123; if(treeNode!=null) &#123; LDRTree(treeNode.left); TreeNodeData(treeNode); LDRTree(treeNode.right); &#125;&#125; 中序遍历算法123456789void LDRTree(CBTType treeNode)&#123; if(treeNode!=null) &#123; LDRTree(treeNode.left); TreeNodeData(treeNode); LDRTree(treeNode.right); &#125;&#125; 后序遍历算法123456789void LRDTree(CBTType treeNode)&#123; if(treeNode!=null) &#123; LRDTree(treeNode.left); LRDTree(treeNode.right); TreeNodeData(treeNode); &#125;&#125; 图结构图结构是一种非线性数据结构，图结构在实际生活中具有丰富的例子，例如通信网络、交通网络、人际关系网等 什么是图结构之前的树结构虽然具有层次关系，但是每个下层元素只能和一个上层元素关联，图结构可以使每个数据元素之间相互关联一个典型的图结构包含： 顶点（vertex）:途中的数据元素 边（Edge）：图中连接这些顶点的线所有的顶点构成一个顶点集合，所有的边构成边集合，一个完整的图结构由顶点集合和边集合组成，图结构在数学上一般记为如下方式：G=（V,E）=(V(G),E(G)) 其顶点集合和边集合如下： V(G)={V1，V2，V3，V4，V5，V6}E(G)={(V1，V2),(V1，V3),(V1,V5)…(V5,V6)} 图的基本概念 无向图边的指向没有方向性，(V1,V2)和(V2,v1)一样V(G)={V1，V2，V3，V4，V5，V6}E(G)={(V1，V2),(V1，V3),(V1,V5)…(V5,V6)} 有向图类似于向量，有指向和不一样V(G)={V1，V2，V3，V4，V5，V6}E(G)={,,(V2,V3)…(V5,V6)} 顶点的度连接顶点的边的数量，在无向图中记作D(V)，在有向图中，分为入度，记作ID(V)，出度，记作OD(V) 邻接顶点邻接顶点是指图结构中一条边的两个顶点，在无向图中，两个顶点无区别，在有向图中，根据边的指向分为入边邻接点和出边邻接点 无向完全图在无向图中，每两个顶点之间都存在一条边 有向完全图在有向图中，每两个顶点之间都存在方向相反的两条边 子图类似于集合的概念，一个子图的顶点和边都应该是另一个图结构的子集合 路径路径即图结构中的顶点之间的连线（之间途径其他顶点），路径上边的数量称为路径长度 连通、连通图和连通分量 如果图结构中两个顶点之间有路径，则称这两个顶点是连通的 如果无向图中任意两个顶点都是连通的，那么这个图称为连通图，否则称为非连通图 无向图的极大连通图称为该图的非连通图 强连通图和强连通分量 权在实际的应用中往往需要将边表示成某种数值，这个数值便是该边的权，无向图中加入权值，则称为无向带权图 网网即边上带有权值的图的另一名称 准备数据（创建图结构用到的数据变量和数据结构）在实际应用中，通常采用结构数组的形式来单独保存顶点的信息，然后采用二维数组的形式保存顶点之间的联系，这种保存顶点之间关系的数组称为邻接矩阵。对于一个包含n个顶点的图，可以使用如下语句来声明一个数组保存顶点的信息12char[] Vertex=new char[MaxNum] //保存顶点信息int[][] EdgeWeight=new int[MaxNum][MaxNum] //保存边上的权（连接关系） 在表示连接关系时，该二维数组中的元素EdgeVeight[i][j]=1表示（Vi,Vj）或者，两个顶点之间的关系EdgeVeight[i][j]=0无向图中，可以用一维数组保存顶点信息 123Vertex[1]=1;Vertex[2]=2... 代码示例：1234567891011static final int MaxNum=20;static final int MaxValue=65535;class GraphMatrix&#123; char[] Vertex=new char[MaxNum]; int GType;//图的类型（0为无向图，1为有向图） int VertexNum; int EdgeNum; int[][] EdgeWeight=new int[MaxNum][MaxNum]//保存边的权重 iint[] isTrav=new int[MaxNum];//遍历标志&#125; 初始化图123456789101112131415void CreateGraph(GraphMatrix GM)&#123; int i,j,k; int weight; char Estart,EndV;//边的起始顶点 System.out.printf(\"输入图中各顶点的信息\\n\"); for(i=0;i&lt;GM.VertexNum;i++) &#123; System.out.printf(\"第%d各个顶点：\",i+1); GM.Vertex[i]=(input.next().toCharArray())[0]; //保存到各顶点数组元素中 &#125; &#125; 清空图即将一个图结构变成一个空图，这里只需将各个元素设置为MaxValue即可12345678910111213void ClearGraph(GraphMatrix GM)&#123; int i,j; for(i=0;i&lt;GM.VertexNum;i++) &#123; for(j=0;j&lt;GM.VertexNum;j++) &#123; GM.EdgeWeight[i][j]=GraphMatrix.MaxValue; //设置矩阵中各元素的值为maxvalue &#125; &#125;&#125; 显示图显示图即为显示图的邻接矩阵，用户可以通过邻接矩阵方便地了解图的顶点和边等结构的信息。12345678910111213141516171819202122232425void OutGraph(GraphMatrix GM)&#123; int i,j; for(j=0;j&lt;GM.VertexNum;j++) &#123; System.out.printf(\"\\t%c\",GM.Vertex[j]); &#125; System.out.printf(\"\\n\"); for(i=0;i&lt;GM.VertexNum;i++) &#123; System.out.printf(\"%c\",GM.Vertex[i]); for(j=0;j&lt;GM.VertexNum;j++) &#123; if(GM.EdgeWeight[i][j]==GraphMatrix.MaxValue) &#123; System.out.printf(\"\\tZ\"); &#125; else &#123; System.out.printf(\"\\t%d\",GM.EdgeWeight[i][j]); &#125; &#125; System.out.printf(\"\\n\"); &#125;&#125; 遍历图遍历图即逐个访问图中的所有的顶点，由于图的结构复杂，存在多对多的特点，因此，当顺着某一路径访问该顶点时，可能会顺着另一路径回到该顶点。常用的手段是在图结构中设置一个数组isTrav[n],该数组的各元素的初始值为零，当某个顶点被遍历访问过时，则设置对应的数据元素值为1。在访问某个顶点i时，先判断数组isTrav[i]中的值，如果其值为1，则继续路径的下一个顶点；如果其值为0，则访问当前顶点（进行相应的处理），然后继续路径的下一个顶点。常用的遍历方法有两种：广度优先遍历法和深度优先遍历法，深度优先遍历方法如下所示： 从数组isTrav中选择一个未访问的顶点Vi，将其标记为1，表示已经访问过。 从Vi的一个未被访问的邻接点出发进行深度优先遍历 重复上一个步骤，直至图中所有和Vi有路径相通的顶点都被访问过。 重复步骤（1）至步骤（3）的操作，直到图中的所有顶点都被访问过。 深度优先遍历法是一个递归过程，具体的程序代码实现如下：12345678910111213141516171819202122232425262728293031323334void DeepTraOne(GraphMatrix GM,int n)&#123; int i; GM.isTrav[n]=1; System.out.printf(\"-&gt;%c\",GM.Vertex[n]; //添加处理结点的操作 for(i=0;i&lt;GM.VertexNum;i++) &#123; if(GM.EdgeWeight[n][i]!=GraphMatrix.MaxValue&amp;&amp;GM.isTrav[n]==0) &#123; DeepTraOne(GM,i); &#125; &#125;&#125;void DeepTraGraph(GraphMatrix GM)&#123; int i; for(i=0;i&lt;GM.VertexNum;i++) &#123; GM.isTrav[i]=0; &#125; System.out.printf(\"深度优先遍历结点\"); for(i=0;i&lt;GM.VertexNum;i++) &#123; if(GM.isTrav[i]==0) &#123; DeepTraOne(GM,i); &#125; &#125; System.out.printf(\"\\n\");&#125; 在上述代码中，方法DeepTraOne()从第n个结点开始深度遍历图，其输入参数GM为一个指向图结构的引用，输入参数n为顶点编号，通过通过递归实现遍历。方法DeepTraGraph()用于执行完整的深度优先遍历，以访问所有的顶点。其中，输入参数GM为一个指向图结构的引用，程序中通过调用方法DeepTraOne()来完成遍历所有顶点的遍历。","categories":[{"name":"职场进阶","slug":"职场进阶","permalink":"http://yoursite.com/categories/职场进阶/"}],"tags":[]},{"title":"css样式","slug":"css样式","date":"2017-11-27T11:24:11.000Z","updated":"2017-12-26T14:12:45.132Z","comments":true,"path":"2017/11/27/css样式/","link":"","permalink":"http://yoursite.com/2017/11/27/css样式/","excerpt":"CSS背景css允许应用纯色作为背景，也允许使用背景图像创建相当复杂的效果","text":"CSS背景css允许应用纯色作为背景，也允许使用背景图像创建相当复杂的效果12345p&#123;background-color:gray&#125;&lt;!--如果希望背景色从元素中的文本向外少有延伸，只需增加一些内边距--&gt;p&#123;background-color: gray;padding: 20px&#125;&lt;!--如果需要设置背景图像，需要为这个图像设置一个路径值--&gt;body&#123;background-image: url(/i/eg_bg_04.gif);&#125; 1234567891011121314151617&lt;html&gt;&lt;head&gt;&lt;style type=\"text/css\"&gt;body&#123; background-image: url(/i/eg_bg_03.gif);background-repeat: repeat-y&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 背景定位：可以利用background-position属性改变图像在背景中的位置下面的例子在body元素中将一个图像居中放置 new APlayer({ element: document.getElementById(\"aplayer4\"), narrow: false, autoplay: true, showlrc: 0, music: { title: \"爱江山更爱美人\", author: \"李丽芬\", url: \"http://ozjh9fb7b.bkt.clouddn.com/%E7%88%B1%E6%B1%9F%E5%B1%B1%E6%9B%B4%E7%88%B1%E7%BE%8E%E4%BA%BA%20%20%20%E6%9D%8E%E4%B8%BD%E8%8A%AC.mp3\", pic: \"\", } }); 123456body &#123; background-image:url('/i/eg_bg_03.gif'); background-repeat:no-repeat; background-position:center; &#125; 背景关联：如果文档比较长，那么文档向下滚动时，背景图像也会随之滚动，当文档滚动到超过图像的位置时，图像就会消失，可以通过background-attachment属性防止这种滚动。123456body &#123; background-image:url(/i/eg_bg_02.gif); background-repeat:no-repeat; background-attachment:fixed &#125; CSS文本CSS文本属性可以定义文本的外观，修改颜色，字符家具，对齐文本，装饰文本，对文本进行缩进缩进文本1p&#123;text-indent:5em;&#125; 缩进的继承123456789div#outer &#123;width: 500px;&#125;div#inner &#123;text-indent: 10%;&#125;p &#123;width: 200px;&#125;&lt;div id=\"outer\"&gt;&lt;div id=\"inner\"&gt;some text. some text. some text.&lt;p&gt;this is a paragragh.&lt;/p&gt;&lt;/div&gt;&lt;/div&gt; 水平对齐text-align是一个基本属性，它会影响一个元素中的文本行互相之间的对齐方式，left、right、center和justify字间隔word-spacing 可以改变单词之间的标准间隔，其默认值为normal与设置值为0是一样的12345678910p.spread &#123;word-spacing: 30px;&#125;p.tight &#123;word-spacing: -0.5em;&#125;&lt;p class=\"spread\"&gt;This is a paragraph. The spaces between words will be increased.&lt;/p&gt;&lt;p class=\"tight\"&gt;This is a paragraph. The spaces between words will be decreased.&lt;/p&gt; 字母间隔：letter-spacing与word-spacing的区别在于，字母间隔修改的是字符或字母之间的间隔12345h1 &#123;letter-spacing: -0.5em&#125;h4 &#123;letter-spacing: 20px&#125;&lt;h1&gt;This is header 121``/h1&gt;&lt;h4&gt;This is header 4&lt;/h4&gt; 字符转换text-transform属性处理文本的大小写，这个属性有4个值“none，uppercase(全部转为大写)，lowercase（全部转为小写）和capitalize h1{text-transform: uppercase} 文本装饰text-decoration属性，这个属性有5个值：none，underline,overline,line-through,blink a{text-decoration: none;} 还可以在一个规则中结合多种装束，如果希望所有超链接既有下划线，又有上划线，规则如下： a:link a:visited{text-decoration:underline overline;} 不过要主要的是，如果两个不同的装饰都与同一元素匹配，胜出规则的值会完全取代另一个值， h2.stricken{text-decoration: line-through;} h2{text-decoration: underline overline;} 处理空白符white-space属性会影响到用户代理对源文档中的空格、换行和tab字符的处理，其值有：normal,pre,nowrap,pre-wrap和pre-line12&lt;p&gt;This is paragraph has many spaces in it.&lt;/p&gt;p&#123;whit-space: normal&#125; 值pre将white-space设置为pre，受这个属性影响的元素中，空白符的处理就有所不同white-space属性的行为 值 空白符 换行符 pre-lien 合并 保留 normal 合并 忽略 nowrap 合并 忽略 pre 保留 保留 pre-wrap 保留 保留 文本方向direction属性影响块级元素文本的书写方向、表中列布局的方向、内容水平填充其元素框的方向，以及两端对齐元素中的最后一行的位置，对于行内元素，只有当unicode-bidi属性设置为embed或bidi-override时才会调用direction属性。direction属性值对应有两个分别为：ltr和rtl CSS字体字体系列font-family&gt;例如:body{font-family:Serif字体，Sans-serif字体,Monospace字体,Cursive字体和Fantasy字体}字体风格font-style&gt;例如：font-style:normal文本正常显示 italic文本斜体显示 oblique文本倾斜显示123p.normal&#123;font-style:normal;&#125;p.italic&#123;font-style:italic;&#125;p.oblique&#123;font-style:oblique;&#125;字体变形font-variant可以设定小型大写字母1p&#123;font-variant:small-caps;&#125;字体加粗font-weight属性设置文本的粗细123p.normal &#123;font-weight:normal;&#125;p.thick &#123;font-weight:bold;&#125;p.thicker &#123;font-weight:900;&#125;字体大小font-size(单位多种，如60px,em，百分比) CSS链接：以不同的方式为链接设置样式链接样式的属性包括：color,font-family,background链接的四种状态： a:link 普通的，未被访问的链接 a:visited 用户已访问的链接 a:hover 鼠标指针位于链接的上方 a:active 链接被点击的时刻 CSS列表：允许改变属性放置、改变列表项标志，或者将图像作为列表项标志例如，在一个无序列表中，列表项的标志是出现在各项表项旁边的圆点，在有序列表中，标志可能是字母、数字或另外某种计数体系中的一个符号要修改用于列表项的标志类型，可以使用属性：list-style-type ul{list-style-type:square} 使用列表项图像list-style-image ul li{list-style-image :url(xxx.gif)} 使用列表标志位置list-style-position li{list-style:url(example.gif) quare indide} CSS表格（可以帮助极大改善表格的外观）表格边框，如需在CSS中设置表格边框，请使用border属性123table,th,td&#123; border: 1px solid blue;&#125; 折叠边框border-collapse123456table&#123; border-collapse:collapse;&#125;table,th,td&#123; border: 1px solid black;&#125; 表格宽度和高度width和height123456table&#123; width:100%;&#125;th&#123; height: 50px;&#125; 表格文本对齐text-align和vertical-align1234567td&#123; text-align:right;&#125;td&#123; height:50px; vertical-align:bottom;&#125; 表格内边框，如需控制表格中内容与边框的距离，请为td和th元素设置padding的属性123td&#123; padding:15px;&#125; 表格颜色1234567table,td,th&#123; border:1px solid green;&#125;th&#123; background-color:green; color:white;&#125; CSS Table属性 属性 描述 border-collapse 设置是否把表格边框合并为单一的边框 border-spacing 设置分隔单元格边框的距离 caption-side 设置表格标题的位置 empty-cells 设置是否显示表格中的空单元格 table-layout 设置显示单元、行和列的算法 CSS轮廓轮廓（outline）是绘制与元素周围的一条线，位于边框外缘的外围，可以起到突出元素的作用，CSS outline属性规定元素轮廓的样式、颜色和宽度包括：outline-style，outline-color,outline-wid12345678910111213141516&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"&gt;&lt;html&gt;&lt;head&gt;&lt;style type=\"text/css\"&gt;p &#123;border:red solid thin;outline:#00ff00 dotted thick(定于了段落p的外围轮廓);&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;b&gt;注释：&lt;/b&gt;只有在规定了 !DOCTYPE 时，Internet Explorer 8 （以及更高版本） 才支持 outline 属性。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"职场进阶","slug":"职场进阶","permalink":"http://yoursite.com/categories/职场进阶/"}],"tags":[{"name":"CSS样式","slug":"CSS样式","permalink":"http://yoursite.com/tags/CSS样式/"}]},{"title":"CSS基础教程","slug":"CSS知识概要","date":"2017-11-27T10:13:13.000Z","updated":"2017-12-26T14:13:19.237Z","comments":true,"path":"2017/11/27/CSS知识概要/","link":"","permalink":"http://yoursite.com/2017/11/27/CSS知识概要/","excerpt":"new APlayer({ element: document.getElementById(\"aplayer0\"), narrow: false, autoplay: true, showlrc: 0, music: { title: \"爱江山更爱美人\", author: \"李丽芬\", url: \"http://ozjh9fb7b.bkt.clouddn.com/%E7%88%B1%E6%B1%9F%E5%B1%B1%E6%9B%B4%E7%88%B1%E7%BE%8E%E4%BA%BA%20%20%20%E6%9D%8E%E4%B8%BD%E8%8A%AC.mp3\", pic: \"\", } }); CSS基础语法css规则主要由两个主要部分构成：选择器+一条多条声明1selector&#123;declaration 1;declaration 2;...declaration N&#125; 选择器通常是需要改变样式的html元素 每条声明由一个属性和一个值构成 属性（property）是希望设置的样式属性（style attribute）。每个属性有一个值，属性与值被冒号分开","text":"new APlayer({ element: document.getElementById(\"aplayer0\"), narrow: false, autoplay: true, showlrc: 0, music: { title: \"爱江山更爱美人\", author: \"李丽芬\", url: \"http://ozjh9fb7b.bkt.clouddn.com/%E7%88%B1%E6%B1%9F%E5%B1%B1%E6%9B%B4%E7%88%B1%E7%BE%8E%E4%BA%BA%20%20%20%E6%9D%8E%E4%B8%BD%E8%8A%AC.mp3\", pic: \"\", } }); CSS基础语法css规则主要由两个主要部分构成：选择器+一条多条声明1selector&#123;declaration 1;declaration 2;...declaration N&#125; 选择器通常是需要改变样式的html元素 每条声明由一个属性和一个值构成 属性（property）是希望设置的样式属性（style attribute）。每个属性有一个值，属性与值被冒号分开 1selector&#123;property: value&#125; 例如，将h1元素内的文字颜色定义为红色，同时将字体大小设置为14像素12h1&#123;color:red;font-size:14px&#125;p&#123;color:#ff0000&#125; 当值value为若干单词时，要给值加双引号1p&#123;font-family:\"sans serif\"&#125; 多重说明p{ text-align: center; color: black; font-family: arial;} new APlayer({ element: document.getElementById(\"aplayer1\"), narrow: false, autoplay: true, showlrc: 0, music: { title: \"爱江山更爱美人\", author: \"李丽芬\", url: \"http://ozjh9fb7b.bkt.clouddn.com/%E7%88%B1%E6%B1%9F%E5%B1%B1%E6%9B%B4%E7%88%B1%E7%BE%8E%E4%BA%BA%20%20%20%E6%9D%8E%E4%B8%BD%E8%8A%AC.mp3\", pic: \"\", } }); CSS高级语法选择器分组：分组的选择器可以分享相同的声明123h1,h2,h3,h4,h5,h6&#123; color:green;&#125; 继承及其问题根据CSS，子元素从父元素继承属性123456789body&#123; font-family: Verdana,sans-serif;&#125;td,ul,ol,li,dl,dt,dd&#123; font-family: Verdana,sans-serif;&#125;p&#123; font-family: Times,sans-serif;&#125; CSS派生选择器通过依据元素在其位置的上下文关系定义样式，可以使标记更加简洁比如，希望列表中的strong元素变为斜体字，而不是通常的粗体字，可以这样定义一个派生选择器123456789101112131415li strong&#123; font-family: italic; font-weight: normal;&#125;strong&#123; color: red;&#125;h2&#123; color: red;&#125;h2 strong&#123; color: yellow;&#125; CSS id选择器可以为标有特定id的html元素指定的样式id选择器以“#”定义 下面的两个id选择器，第一个定义元素的颜色为红色，第二个定义元素的颜色为绿色12#red &#123;color:red;&#125;#green &#123;color: green;&#125; 在对应的html文档中，id属性为red的p元素显示为红色，而id属性为green的p元素显示为绿色12&lt;p id=\"red\"&gt;这个段落是红色&lt;/p&gt;&lt;p id=\"green\"&gt;这个段落是绿色&lt;/p&gt; id选择器和派生选择器在布局中，id选择器常常用于建立派生选择器,一个选择器，多种用法,单独的选择器1234567891011#sidebar p&#123; font-style: italic; text-align: right; margin-top: 0.5em;&#125;#sidebar h2&#123; font-style: italic; text-align: right; margin-top: 0.5em;&#125; CSS类选择器在CSS中，类选择器以一个点号显示,下述的center是类名1.center&#123;text-align: center&#125; 在对应的html文档中123456&lt;h1 class=\"center\"&gt;this heading will be center-aligned&lt;/h1&gt;&lt;p class=\"center\"&gt;this paragraph will also be center-aligned. 同id选择器一样，class选择器也可被用作派生选择器1234.fancy td&#123; color:#f60; background: #666;&#125; CSS属性选择器对带有指定属性的HTML元素设置样式，可以为拥有指定属性的HTML元素设置样式，而不仅限于class和id属性下面的例子为带有title属性的所有元素设置样式1234[title=w3school]&#123; color:red;&#125; 12345678910111213141516171819202122&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"&gt;&lt;html&gt;&lt;head&gt;&lt;style type=\"text/css\"&gt;[title~=hello]&#123;color:red;&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;可以应用样式：&lt;/h1&gt;&lt;h2 title=\"hello world\"&gt;Hello world&lt;/h2&gt;&lt;p title=\"student hello\"&gt;Hello W3School students!&lt;/h1&gt;&lt;hr /&gt;&lt;h1&gt;无法应用样式：&lt;/h1&gt;&lt;h2 title=\"world\"&gt;Hello world&lt;/h2&gt;&lt;p title=\"student\"&gt;Hello W3School students!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 设置表单的样式1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt;input[type=\"text\"]&#123; width:150px; display:block; margin-bottom:10px; background-color:yellow; font-family: Verdana, Arial;&#125;input[type=\"button\"]&#123; width:120px; margin-left:35px; display:block; font-family: Verdana, Arial;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;form name=\"input\" action=\"\" method=\"get\"&gt;&lt;input type=\"text\" name=\"Name\" value=\"Bill\" size=\"20\"&gt;&lt;input type=\"text\" name=\"Name\" value=\"Gates\" size=\"20\"&gt;&lt;input type=\"button\" value=\"Example Button\"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 如何创建CSS当读到一个样式表时，浏览器会根据它来格式化html文档，插入样式表的方法有三种： 外部样式表123&lt;head&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"mystyle.css\"/&gt;&lt;/head&gt; 浏览器会从文件mystyle.css中读到样式声明，并根据它来格式文档 外部样式表可以在任何文本编辑器中编辑，mystyle.css文件：1234567891011121314151617181920212223hr&#123;color: sienna;&#125;p&#123;margin-left: 20px;&#125;body&#123;background-image: url(\"images/back40.gif\")&#125;``` 外部样式表实例外部样式表文件```css/*charset用于指定样式表使用的字符集，该关键字只能用于外部样式表文件中，并位于样式表的最前面，只允许出现一次*/@charset \"utf-8\"h1&#123; color: #033; border:dashed 1px #6600c;&#125;hr&#123; width: 95%; text-align: center; color:#03C;&#125;span&#123; font-wight:bold;&#125; 123456789101112&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html\";charset=\"utf-8\"&gt; &lt;title&gt;连接外部样式表的使用&lt;/title&gt; &lt;link type=\"text/css\" rel=\"stylesheet\" href=\"css/style.css\"/&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;连接外部样式表的使用&lt;/h1&gt; &lt;hr&gt;连接外部样式表&lt;/hr&gt; &lt;/body&gt;&lt;/html&gt; 内部样式表（嵌入到head中） 1234567&lt;head&gt;&lt;style type=\"text/css\"&gt;hr&#123;color:sienna;&#125;p&#123;margin-left: 20px;&#125;body&#123;background-image: url(images/back40.gif;&#125;&lt;/style&gt;&lt;/head&gt; 内联样式（在body中对局部进行格式化） 123&lt;p style=\"color: sienna; margin-left: 20px\"&gt;This is a paragraph&lt;/p&gt; 多重样式 1234567891011外部样式表对h3进行定义h3&#123; color: red; text-align: left; font-size: 8pt;&#125;内部样式表同样对h3进行定义h3&#123; text-align: right; font-size: 20pt;&#125; 即颜色属性将被继承于外部样式表，而文字排列和字体尺寸会被内部样式表中的规则取代 div+css样式html示例1234567891011121314151617181920212223242526&lt;!DOCTYPE html PUBBIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"&gt;&lt;html xmlns=\"http://www.w3.org/1999/xhtml\"&gt;&lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/css\" charset=\"UTF-8\"/&gt; &lt;title&gt;页面内容框架&lt;/title&gt; &lt;link type=\"text/css\" rel=\"stylesheet\" href=\"structureDemo.css\"/&gt;&lt;/head&gt;&lt;div&gt; &lt;div id=\"containerDiv\"&gt; &lt;div id=\"bannerDiv\"&gt;&lt;/div&gt; &lt;div id=\"navigationDiv\"&gt;&lt;/div&gt; &lt;div id=\"focusDiv\"&gt; &lt;div id=\"leftDiv\"&gt;&lt;/div&gt; &lt;div id=\"rightDiv\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"clearBoth\"&gt;&lt;/div&gt; &lt;!--清除前面浮动对后面元素的影响--&gt; &lt;div id=\"content1\"&gt;&lt;/div&gt; &lt;div id=\"content2\"&gt;&lt;/div&gt; &lt;div id=\"content3\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"clearBoth\"&gt;&lt;/div&gt; &lt;!--清除前面浮动对后面元素的影响--&gt; &lt;div id=\"footerDiv\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374@charset \"utf-8\"; body,div&#123; margin: 0px; padding: 0px; &#125; #containerDiv&#123; margin: 0 auto; width: 1000px; height:750px; background-color: #CCC; &#125; #bannerDiv&#123; width: 100%; height:100px; background-color: #BBB; &#125; #navigationDiv&#123; width:100%; height:50px; background-color: #888; &#125; #focusDiv&#123; width:100%; height:200px; background-color: #EEE; padding: 4px 0px; &#125; #containerDiv&#123; width:100%; height:200px; background-color: #999; padding-top: 3px 0px; &#125; #footerDiv&#123; width: 100%; height:90px; background-color: #BBB; margin-top: 3px; &#125; #leftDiv&#123; width:60%; height:90px; background-color: #CCC; float:left; &#125; #rightDiv&#123; width:39%; height:99%; background-color: #CCC; float: right; &#125; #content1&#123; width:330px; height:98%; background-color: #CCC; float:left; &#125; #content2&#123; width:330px; height:98%; background-color: #CCC; float:left; margin-left: 4px; &#125; #content3&#123; width:330px; height:98%; background-color:#CCC; float:left; marging-left:4px; &#125; .clearBoth&#123; clear:both; &#125;","categories":[{"name":"职场进阶","slug":"职场进阶","permalink":"http://yoursite.com/categories/职场进阶/"}],"tags":[{"name":"CSS基础知识","slug":"CSS基础知识","permalink":"http://yoursite.com/tags/CSS基础知识/"}]},{"title":"html知识概要","slug":"html","date":"2017-11-27T00:53:24.000Z","updated":"2017-12-26T14:10:33.060Z","comments":true,"path":"2017/11/27/html/","link":"","permalink":"http://yoursite.com/2017/11/27/html/","excerpt":"html标签html标记标签通常称为html标签（html tag）html标签由尖括号包围，通常成对出现的，比如:&lt;b&gt;…&lt;/b&gt;","text":"html标签html标记标签通常称为html标签（html tag）html标签由尖括号包围，通常成对出现的，比如:&lt;b&gt;…&lt;/b&gt; html文档=网页html编辑器 &nbsp;&nbsp;notepad 或 textedit或 Adobe Dreamweaver html头部文档的标题：&lt;title&gt;定义文档的标题所有链接一个目标 &lt;head&gt; &lt;base href=&quot;http://www.baidu.com&quot;&gt; &lt;base target=&quot;_blank&quot;&gt; &lt;/head&gt; 文档描述：&lt;meta&gt;描述文档,提供关于html文档的元数据，规定页面的描述，关键词，文档的作者，最后的修改时间以及其他元数据等&lt;meta name=”description” content=”Free Web tutorials on HTML, CSS, XML”&gt;重定向用户：如何把用户定向添加到新的网址 html基础注释&lt;!–注释内容–&gt;html标题 &lt;h1&gt;…&lt;h1&gt;html段落 &lt;p&gt;…&lt;/p&gt;（可以用&lt;br/&gt;强制换行）html标签 &lt;a href=”www.baidu.com”&gt;这是百度&lt;/a&gt;下划线 &lt;hr/&gt;html图像 &lt;img src=”图片.jpg” width=”100” height=”50” alt=”Big Boat(鼠标移至该图片时出现的提示信息)”&gt;背景图片&lt;html&gt; &lt;body background=&quot;/i/eg_background.jpg&quot;&gt; &lt;h3&gt;图像背景&lt;/h3&gt; &lt;p&gt;gif 和 jpg 文件均可用作 HTML 背景。&lt;/p&gt; &lt;p&gt;如果图像小于页面，图像会进行重复。&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 空格 &lt;br/&gt;html元素（元素与标签的区别）指开始标签和结束标签之间的所有代码 html属性(可参考html属性手册)标签拥有属性，属性总是以名称/值的形式出现，例如：&lt;a href=”www.baidu.com” target=”_blank”&gt;百度&lt;/a&gt; target指向blank表示指向的链接在新页面打开 html链接命名锚：在html文档中对锚进行定义，创建锚 &lt;a name=”tips”（锚的地址）&gt;基本的注意事项(锚的名称)&lt;/a&gt;指向锚: 然后在该文档中创建指向该锚的链接 &lt;a href=”#tips”&gt;有用的提示&lt;/a&gt;属性：名称=值 &lt;h2 style=”background-color: green”&gt;This is a paragraph&lt;/h2&gt; html格式化所谓的格式化，（赋予文本一定的格式）可定义很多供格式化输出的元素，比如粗体和斜体字 文本格式化标签 &lt;b&gt; 定义粗体文字 &lt;big&gt; 定于大号字 &lt;em&gt; 定义着重文字 &lt;i&gt; 定义斜体字 &lt;small&gt;&lt;/small&gt; 定义小号字 &lt;strong&gt; 定义加重语气 &lt;sub&gt; 定义下表字 &lt;sup&gt; 定义上标字 &lt;ins&gt; 定义插入字 &lt;del&gt; 定义删除字（字被杠掉） 计算机输出标签 &lt;code&gt; 定义计算机代码 &lt;kbd&gt; 定义键盘码 &lt;samp&gt; 定义计算机代码样本 &lt;tt&gt; 定义打字机代码 &lt;var&gt; 定义变量 &lt;pre&gt; 定义预格式文本 引用、引用和术语定义 &lt;abbr&gt; 定义缩写:&lt;abbr title=&quot;World Health Organization&quot;&gt;WHO&lt;/abbr&gt;&gt; 鼠标移至WHO时，会出现全称提示 &lt;acronym&gt; 定义首字母缩写 &lt;address&gt; 定义地址 &lt;bdo&gt; 定义文字方向 &lt;blockquote&gt; 定义长的引用 &lt;q&gt; 定义短的引用语 &lt;cite&gt; 定义引用、印证 &lt;dfn&gt; 定义一个定义项目 html css通过使用HTML4.0,所有的格式化代码均可移出html文档，然后移入一个独立的样式表，格式化怎么理解？ html中的样式当单个文件需要特别样式时，就可以使用内部样式表 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;style type=&quot;text/css&quot;&gt; h1{color:red} p{color:blue} &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;header 1&lt;/h1&gt; &lt;p&gt;a paragraph&lt;/p&gt;&gt; &lt;/body&gt; &lt;/html&gt; 没有下划线的链接（内联样式，当特殊的样式需要应用到个别元素时，就可以使用内联样式，样式属性可以包含任何CSS属性）&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=gb2312&quot; /&gt; &lt;meta http-equiv=&quot;Content-Language&quot; content=&quot;zh-cn&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=&quot;/example/html/lastpage.html&quot; style=&quot;text-decoration:none&quot;&gt; 这是一个链接！ &lt;/a&gt; &lt;/body&gt; &lt;/html&gt; 链接到一个外部样式表（使用标签链接到一个外部样式表）当样式需要被应用到很多页面时，外部样式表将是理想的选择。使用外部样式表，便于通过更改一个整个站点的外观 &lt;html&gt; &lt;head&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/html/csstest1.css&quot; &gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;我通过外部样式表进行格式化。&lt;/h1&gt; &lt;p&gt;我也一样！&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 样式属性参考表&lt;style&gt; 定义样式定义 &lt;link&gt; 定义资源引用 &lt;div&gt; 定义文档中的节或区域（块级） &lt;span&gt; 定义文档中的行内的小块或区域 html表格&lt;table border=&quot;1&quot; bgcolor=&quot;red&quot; background=&quot;/图片.jpg&quot;&gt; &lt;tr&gt; &lt;th&gt;表头&lt;/th&gt; &lt;th&gt;表头&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td bgcolor=&quot;red&quot;&gt;row 1, cell 1&lt;/td&gt; &lt;td&gt;row 1, cell 2&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td background=&quot;/图片.jpg&quot;&gt;row 2, cell 1&lt;/td&gt; &lt;td&gt;row 2, cell 2&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 浏览器显示： row 1, cell 1 row 1, cell 2 row 2, cell 1 row 2, cell 2 表格标签&lt;table&gt; 定义表格 &lt;caption&gt; 定义表格标题 &lt;th&gt; 定义表格的表头 &lt;tr&gt; 定义表格的行 &lt;td&gt; 定义表格单元 &lt;thead&gt; 定义表格的页眉 &lt;tbody&gt; 定义表格的主体 &lt;tfoot&gt; 定义表格的页脚 &lt;col&gt; 定义表格列的属性 &lt;colgroup&gt; 定义表格列的组 列表无序列表 &lt;ul&gt; &lt;li&gt;Coffee&lt;/li&gt; &lt;li&gt;milk&lt;/li&gt;&gt; &lt;/ul&gt; 有序列表 &lt;ol&gt; &lt;li&gt;Coffee&lt;/li&gt; &lt;li&gt;milk&lt;/li&gt;&gt; &lt;/ol&gt; html块可以通过&lt;div&gt;和&lt;span&gt;将html元素组合起来html&lt;div&gt;元素是快加元素，它是可用于组合其他html元素的容器&lt;div&gt;元素没有特定的含义，除此之外，由于它属于块级元素，浏览器会在其后显示折行如果与css一同使用，&lt;div&gt;元素可用于对大的内容块设置样式属性&lt;div&gt;元素的另一个常见的用途是文档布局，它取代了使用表格定义布局的老式方法，使用&lt;table&gt;元素进行文档布局不是表格的正确用法，元素的作用是显示表格化的数据 html&lt;span&gt;元素是内联元素，可用作文本的容器&lt;span&gt;元素也没有特定的含义当与CSS一同使用时，&lt;span&gt;元素可用于为部分文本设置样式属性。 html类对html进行分类（设置类），使我们能够为元素类定义CSS样式，为相同的类设置相同的样式，或者为不同的类设置不同的样式&lt;div&gt;示例 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;style&gt; .cities { background-color:black; color:white; margin:20px; padding:20px; } .cities_2{ background-color:red; color:white; margin:20px; padding:20px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!--分块，从head区中引用相应的style--&gt; &lt;div class=&quot;cities&quot;&gt; &lt;h2&gt;London&lt;/h2&gt; &lt;p&gt;London is the capital city of England. It is the most populous city in the United Kingdom, with a metropolitan area of over 13 million inhabitants.&lt;/p&gt; &lt;p&gt;Standing on the River Thames, London has been a major settlement for two millennia, its history going back to its founding by the Romans, who named it Londinium.&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;cities_2&quot;&gt; &lt;h2&gt;Paris&lt;/h2&gt; &lt;p&gt;Paris is the capital and most populous city of France.&lt;/p&gt; &lt;p&gt;Situated on the Seine River, it is at the heart of the 蝜e-de-France region, also known as the r間ion parisienne.&lt;/p&gt; &lt;p&gt;Within its metropolitan area is one of the largest population centers in Europe, with over 12 million inhabitants.&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;cities&quot;&gt; &lt;h2&gt;Tokyo&lt;/h2&gt; &lt;p&gt;Tokyo is the capital of Japan, the center of the Greater Tokyo Area, and the most populous metropolitan area in the world.&lt;/p&gt; &lt;p&gt;It is the seat of the Japanese government and the Imperial Palace, and the home of the Japanese Imperial Family.&lt;/p&gt; &lt;p&gt;The Tokyo prefecture is part of the world&apos;s most populous metropolitan area with 38 million people and the world&apos;s largest urban economy.&lt;/p&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; &lt;span&gt;示例；内联样式 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;style&gt; span.red {color:red;} &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;My &lt;span class=&quot;red&quot;&gt;Important&lt;/span&gt; Heading&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; html布局（网站的结构布局）使用&lt;div&gt;元素的html布局：&lt;div&gt;元素常用作布局工具，因为能够轻松通过CSS对其进行定位这个例子使用了四个&lt;div&gt;元素来创建的多列布局 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;!--style内部的CSS样式--&gt; &lt;style&gt; #header { background-color:black; color:white; text-align:center; padding:5px; } #nav { line-height:30px; background-color:#eeeeee; height:300px; width:100px; float:left; padding:5px; } #section { width:350px; float:left; padding:10px; } #footer { background-color:black; color:white; clear:both; text-align:center; padding:5px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;header&quot;&gt; &lt;h1&gt;City Gallery&lt;/h1&gt; &lt;/div&gt; &lt;div id=&quot;nav&quot;&gt; London&lt;br&gt; Paris&lt;br&gt; Tokyo&lt;br&gt; &lt;/div&gt; &lt;div id=&quot;section&quot;&gt; &lt;h2&gt;London&lt;/h2&gt; &lt;p&gt; London is the capital city of England. It is the most populous city in the United Kingdom, with a metropolitan area of over 13 million inhabitants. &lt;/p&gt; &lt;p&gt; Standing on the River Thames, London has been a major settlement for two millennia, its history going back to its founding by the Romans, who named it Londinium. &lt;/p&gt; &lt;/div&gt; &lt;div id=&quot;footer&quot;&gt; Copyright ? W3Schools.com &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; html5语义元素header 定义文档或节的页眉 nav 定义导航链接的容器 section 定义文档中的节 article 定义独立的自包含文章 aside 定义内容之外的内容（比如侧栏） footer 定义文档或节的页脚 details 定义额外的细节 summary 定义details元素的标题 html响应式Web容器 RWD指的是响应式Web涉及（Responsive Web Design） RWD能够以可变尺寸传递网页 RWD对于平板和移动设备是必需的12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang=\"en-US\"&gt;&lt;head&gt;&lt;style&gt;.city &#123;float: left;margin: 5px;padding: 15px;width: 300px;height: 300px;border: 1px solid black;&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;W3School Demo&lt;/h1&gt;&lt;h2&gt;Resize this responsive page!&lt;/h2&gt;&lt;br&gt;&lt;div class=\"city\"&gt;&lt;h2&gt;London&lt;/h2&gt;&lt;p&gt;London is the capital city of England.&lt;/p&gt;&lt;p&gt;It is the most populous city in the United Kingdom,with a metropolitan area of over 13 million inhabitants.&lt;/p&gt;&lt;/div&gt;&lt;div class=\"city\"&gt;&lt;h2&gt;Paris&lt;/h2&gt;&lt;p&gt;Paris is the capital and most populous city of France.&lt;/p&gt;&lt;/div&gt;&lt;div class=\"city\"&gt;&lt;h2&gt;Tokyo&lt;/h2&gt;&lt;p&gt;Tokyo is the capital of Japan, the center of the Greater Tokyo Area,and the most populous metropolitan area in the world.&lt;/p&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; html框架通过使用框架，你可以在同一个浏览器窗口中显示不止一个页面框架标签1234&lt;frameset cols=\"25%,75%\"&gt; &lt;frame src=\"frame_a.html\"&gt; &lt;frame src=\"frame_b.html\"&gt;&lt;/frameset&gt; html内联框架（用于在网页内显示网页）&lt;iframe src=&quot;URL&quot; frameborder=&quot;0&quot; width=&quot;200&quot; height=&quot;100&quot;&gt;...&lt;/frame&gt; URL指向隔离页面的位置 html背景作为body的属性，&lt;body bgcolor=”red”&gt;&lt;/body&gt; html脚本&lt;script type=&quot;text/javascript&quot;&gt; &lt;!-- document.write(&quot;Hello World!&quot;) //--&gt; &lt;/script&gt; html字符实体html中的预留字符必须被替换为字符实体，空格，大于，小于号等 html web服务器html 表单html表单用于搜集不同类型的用户输入用&lt;form&gt;元素定义html表单 &lt;form&gt; form elements &lt;form&gt; html表单包含表单元素表单元素指不同类型的input元素、复选框、单选按钮和提交按钮等 ##&lt;input&gt;元素属性类型 text 定义常规文本输入 radio 定义单选按钮输入（选择多个选择之一） submit 定义提交按钮（提交表单） &lt;input type=”text”&gt;定义用于文本输入的单行输入字段文本输入框实例12345678&lt;form&gt; First name:&lt;br&gt; &lt;!--插入文本框--&gt; &lt;input type=\"text\" name=\"firstname\"&gt; &lt;br&gt; Last name:&lt;br&gt; &lt;input type=\"text\" name=\"lastname\"&gt;&lt;/form&gt; &lt;input type=”radio”&gt;定义单选按钮单选按钮实例12345&lt;form&gt; &lt;input type=\"radio\" name=\"sex\" value=\"male\" checked&gt;Male &lt;br&gt; &lt;input type=\"radio\" name=\"sex\" value=\"female\"&gt;Female&lt;/form&gt; &lt;input type=”submit”&gt;定义用于向表单处理程序12345678910&lt;!--表单结果提交到的位置,method指表单的提交方式，适用于少量提交，并且信息会出现在浏览器中--&gt;&lt;form action=\"action_page.php\" method=\"GET\"&gt; First name:&lt;br&gt; &lt;input type=\"text\" name=\"firstname\" value=\"Mickey\"&gt; &lt;br&gt; Last name:&lt;br&gt; &lt;input type=\"text\" name=\"lastname\" value=\"Mouse\"&gt; &lt;br&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"Submit\"&gt;&lt;/form&gt; 用&lt;fieldset&gt;组合表单数据&lt;legend&gt;元素为&lt;fieldset&gt;元素定义标题，把下面的几个文本框联系到一起，框成一个整体123456789101112&lt;form action=\"action_page.php\"&gt; &lt;fieldset&gt; &lt;legend&gt;Personal information&lt;/legend&gt; First name:&lt;br&gt; &lt;input type=\"text\" name=\"firstname\" value=\"mickey\"&gt; &lt;br&gt; Last name:&lt;br&gt; &lt;input type=\"text\" name=\"lastname\" value=\"Mouse\"&gt; &lt;br&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"submit\"&gt; &lt;/fieldset&gt;&lt;/form&gt; html form属性&lt;form action=&quot;action_page.php&quot; method=&quot;GET&quot; target=&quot;_blank&quot; accept-charset=&quot; UTF-8&quot; enctype=&quot;application/x-www-form-urlencoded&quot; autocomplete=&quot;off&quot; novalidate&gt; form elements &lt;/form&gt; &lt;form&gt;属性列表 accept-charset 规定在被提交表单中使用的字符集（默认：页面字符集） action 规定向何处提交表单的地址（url）提交页面 autocomplete 规定浏览器应该自动完成表单（默认开启） enctype 规定被提交数据的编码(默认：url-encoded) method 规定在提交表单时所用的http方法（默认：GET） name 规定识别表单的名称(对于DOM使用：document.forms.name) novalidate 规定浏览器不验证表单 target 规定action属性中地址的目标（默认：_self） &lt;select&gt;元素（下拉列表）实例123456&lt;select name=\"cars\"&gt; &lt;option value=\"volo\"&gt;Volo&lt;/option&gt; &lt;option value=\"saab\"&gt;Saab&lt;/option&gt; &lt;option value=\"fiat\"&gt;Fiat&lt;/option&gt; &lt;option value=\"audi\"&gt;Audi&lt;/option&gt;&lt;/select&gt; textarea元素定义多行输入字段（文本域）实例123&lt;textarea name=\"message\" rows=\"10\" cols=\"30\"&gt; The cat was playing in the garden.&lt;/textarea&gt; button元素定义可点击的按钮，上面的submit也会自动生成一个按钮，这个按钮的功能单一，只是用于向服务器提交表单实例 &lt;button type=”button” onclick=”alert(‘hello world’)”&gt;click me&lt;/button&gt; html5新增表单元素 &lt;datalist&gt;&lt;/datalist&gt;元素为&lt;input&gt;元素规定预定义选项列表，用户会在他们输入数据时看到预定义选项的下拉列表 &lt;keygen&gt;&lt;/keygen&gt; &lt;output&gt;&lt;/output&gt;实例12345678910&lt;form action=\"action_page.php\"&gt; &lt;input list=\"browsers\"&gt; &lt;datalist id=\"browsers\"&gt; &lt;option value=\"Internet Explorer\"&gt; &lt;option value=\"Firefox\"&gt; &lt;option value=\"chrome\"&gt; &lt;option value=\"opera\"&gt; &lt;option value=\"safari\"&gt; &lt;/datalist&gt;&lt;/form&gt; html输入类型,本章描述&lt;input元素的输入类型&gt; input type：text input type: password input type：submit input type: radio input type: checkbox复选框 input type: button html输入属性 value表示输入框中初始值，用于提示，用户可以手动删除，自行添加自己所需的值 readonly属性规定输入字段为只读（不能修改）,不需要属性值，等同于readonly=”readonly” 例如：&lt;input type=”text” name=”firstname” value=”John” readonly&gt; disabled属性规定输入字段是禁用的，被禁用的元素是不可用和不可点击的，被禁用的元素不会被提交 例如：&lt;input type=”text” name=”firstname” value=”John” disabled&gt; size属性规定输入字段的尺寸（以字符计） 例如：&lt;input type=”text” name=”firstname” value=”John” size=”40”&gt; maxlength属性规定输入字段允许的最大长度 例如：&lt;input type=”text” name=”firstname” maxlength=”10”&gt;","categories":[{"name":"职场进阶","slug":"职场进阶","permalink":"http://yoursite.com/categories/职场进阶/"}],"tags":[{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"}]},{"title":"Java web项目开发实例一","slug":"Java-web项目开发实例","date":"2017-11-23T08:40:32.000Z","updated":"2017-12-26T14:17:37.015Z","comments":true,"path":"2017/11/23/Java-web项目开发实例/","link":"","permalink":"http://yoursite.com/2017/11/23/Java-web项目开发实例/","excerpt":"实现简单的用户登录网站，具体功能有：提供一个登录界面（Login）,包括用户名，密码等；然后验证用户输入的信息是否正确（LoginCl），如果正确，跳转提示登录成功的界面；错误则返回到登录界面","text":"实现简单的用户登录网站，具体功能有：提供一个登录界面（Login）,包括用户名，密码等；然后验证用户输入的信息是否正确（LoginCl），如果正确，跳转提示登录成功的界面；错误则返回到登录界面主要知识点：页面的跳转 登录界面(Login.java)：通过html的方式实现，代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.zy.firstWeb;import java.io.PrintWriter;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class Login extends HttpServlet &#123; //处理get请求 //req:用于获得客户端（浏览器）的信息 //res:用于向客户端（浏览器）返回信息 public void doGet(HttpServletRequest req,HttpServletResponse res)&#123; //业务逻辑 try&#123; //中文乱码 res.setContentType(\"text/html;charset=gbk\"); PrintWriter pw=res.getWriter(); //返回登录界面 pw.println(\"&lt;html&gt;\"); pw.println(\"&lt;body&gt;\"); pw.println(\"&lt;h1&gt;登录界面&lt;h1&gt;\"); pw.println(\"&lt;form action=servlet/LoginCI method=post&gt;\"); pw.println(\"用户名:&lt;input type=text name=usrname&gt;&lt;br&gt;\"); pw.println(\"密码:&lt;input type=password name=passwd&gt;&lt;br&gt;\"); pw.println(\"&lt;input type=submit value=loing&gt;&lt;br&gt;\"); pw.println(\"&lt;/form&gt;\"); pw.println(\"&lt;/body&gt;\"); pw.println(\"&lt;/html&gt;\"); &#125; catch(Exception ex)&#123; ex.printStackTrace(); &#125; &#125; //处理post请求 //req:用于获得客户端（浏览器）的信息 //res:用于向客户端（浏览器）返回信息 public void doPost(HttpServletRequest req,HttpServletResponse res)&#123; //用this传给get方法 this.doGet(req,res); &#125;&#125; new APlayer({ element: document.getElementById(\"aplayer2\"), narrow: false, autoplay: true, showlrc: 0, music: { title: \"如果来生还是今世的重复\", author: \"杭宏\", url: \"http://ozjh9fb7b.bkt.clouddn.com/%E6%9D%AD%E5%AE%8F%20-%20%E5%A6%82%E6%9E%9C%E6%9D%A5%E7%94%9F%E8%BF%98%E6%98%AF%E4%BB%8A%E4%B8%96%E7%9A%84%E9%87%8D%E5%A4%8D.mp3\", pic: \"\", } }); 处理、验证用户的登录信息（）LoginCl12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.zy.firstWeb;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;//验证用户提交的信息是否正确，用req@SuppressWarnings(\"serial\")public class LoginCI extends HttpServlet &#123; //处理get请求 //req:用于获得客户端（浏览器）的信息 //res:用于向客户端（浏览器）返回信息 public void doGet(HttpServletRequest req,HttpServletResponse res)&#123; //业务逻辑 try&#123; //接受用户名和密码 String u=req.getParameter(\"usrname\"); String p=req.getParameter(\"passwd\"); //验证 if((u.equals(\"zy\"))&amp;&amp;(p.equals(\"123\")))&#123; //合法 //跳转到wel res.sendRedirect(\"Wel\"); &#125;else&#123; //不合法 //跳转 res.sendRedirect(\"Login\"); //写你要的servlet的那个servlet的url， //myeclipse自动生成的web.xml文件中的url-pattern，格式为/servlet/****,作为跳转对象，浏览器报404错误，认为去掉servlet保留成/***的形式，跳转会成功,可能就不能写成两个/的形式吧！！！！！ &#125; &#125; catch(Exception ex)&#123; ex.printStackTrace(); &#125; &#125; //处理post请求 //req:用于获得客户端（浏览器）的信息 //res:用于向客户端（浏览器）返回信息 public void doPost(HttpServletRequest req,HttpServletResponse res)&#123; //用this传给get方法 this.doGet(req,res); &#125;&#125; 登录成功的欢迎页面（Well.java)123456789101112131415161718192021222324252627282930313233343536373839package com.zy.firstWeb;import java.io.PrintWriter;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class Wel extends HttpServlet &#123; //处理get请求 //req:用于获得客户端（浏览器）的信息 //res:用于向客户端（浏览器）返回信息 public void doGet(HttpServletRequest req,HttpServletResponse res)&#123; //业务逻辑 try&#123; PrintWriter pw=res.getWriter(); pw.println(\"wel.hello\"); &#125; catch(Exception ex)&#123; ex.printStackTrace(); &#125; &#125; //处理post请求 //req:用于获得客户端（浏览器）的信息 //res:用于向客户端（浏览器）返回信息 public void doPost(HttpServletRequest req,HttpServletResponse res)&#123; //用this传给get方法 this.doGet(req,res); &#125;&#125; 配置信息如下：web.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE web-app PUBLIC \"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN\" \"http://java.sun.com/dtd/web-app_2_3.dtd\"&gt;&lt;web-app&gt; &lt;servlet&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;display-name&gt;This is the display name of my J2EE component&lt;/display-name&gt; &lt;description&gt;This is the description of my J2EE component&lt;/description&gt; &lt;servlet-class&gt;com.zy.firstWeb.HelloServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet&gt; &lt;servlet-name&gt;Login&lt;/servlet-name&gt; &lt;display-name&gt;This is the display name of my J2EE component&lt;/display-name&gt; &lt;description&gt;This is the description of my J2EE component&lt;/description&gt; &lt;servlet-class&gt;com.zy.firstWeb.Login&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet&gt; &lt;servlet-name&gt;LoginCI&lt;/servlet-name&gt; &lt;display-name&gt;This is the display name of my J2EE component&lt;/display-name&gt; &lt;description&gt;This is the description of my J2EE component&lt;/description&gt; &lt;servlet-class&gt;com.zy.firstWeb.LoginCI&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet&gt; &lt;servlet-name&gt;Wel&lt;/servlet-name&gt; &lt;display-name&gt;This is the display name of my J2EE component&lt;/display-name&gt; &lt;description&gt;This is the description of my J2EE component&lt;/description&gt; &lt;servlet-class&gt;com.zy.firstWeb.Wel&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/HelloServlet&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;Login&lt;/servlet-name&gt; &lt;url-pattern&gt;/Login&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;LoginCI&lt;/servlet-name&gt; &lt;url-pattern&gt;/LoginCI&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;Wel&lt;/servlet-name&gt; &lt;url-pattern&gt;/Wel&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt;","categories":[{"name":"案例练习","slug":"案例练习","permalink":"http://yoursite.com/categories/案例练习/"}],"tags":[{"name":"servlet开发","slug":"servlet开发","permalink":"http://yoursite.com/tags/servlet开发/"}]},{"title":"servlet开发","slug":"servlet开发","date":"2017-11-22T05:38:58.000Z","updated":"2017-12-26T14:14:01.620Z","comments":true,"path":"2017/11/22/servlet开发/","link":"","permalink":"http://yoursite.com/2017/11/22/servlet开发/","excerpt":"Jsp是基于servlet的，servlet的开发流程如下： 在tomacat的文件夹（\\webapps）下新建servelt名，然后在其中创建WEB-INF的文件夹，WEB-INF文件夹至少包含两个文件夹分别是classes(用于存放servlet程序编译生成的class文件，)，lib文件夹（用于存放包jar，图片等资源），一个文件web.xml 开发servlet（编写程序，引入servlet-api.jar） 部署你的servlet（就是在tomcat那里登记自己开发的servlet的名称位置等信息，通过在WEB-INF文件夹下新建web.xml文件） 启动tomcat，访问你的servlet(在浏览器中输入地址:http//“ip地址（本机可用localhost代替）”:8080/myWebsite/servlet名)","text":"Jsp是基于servlet的，servlet的开发流程如下： 在tomacat的文件夹（\\webapps）下新建servelt名，然后在其中创建WEB-INF的文件夹，WEB-INF文件夹至少包含两个文件夹分别是classes(用于存放servlet程序编译生成的class文件，)，lib文件夹（用于存放包jar，图片等资源），一个文件web.xml 开发servlet（编写程序，引入servlet-api.jar） 部署你的servlet（就是在tomcat那里登记自己开发的servlet的名称位置等信息，通过在WEB-INF文件夹下新建web.xml文件） 启动tomcat，访问你的servlet(在浏览器中输入地址:http//“ip地址（本机可用localhost代替）”:8080/myWebsite/servlet名) servlet程序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import javax.servlet.*;import javax.servlet.ServletConfig;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import java.io.IOException;//这是我的第一个servlet，使用servlet接口的方式实现package com.zy;import javax.servlet.*;import java.io.*;public class Hello &#123;&#125; //该函数用于初始化serlvet（类似于类的构造函数 //该函数只会被调用一次（当用户第一次访问该servlet时被调用） public void init(ServletConfig parm1) throws ServletException &#123; // TODO: Add your code here &#125; public ServletConfig getServletConfig() &#123; // TODO: Add your code here &#125; //该函数用于处理逻辑 //程序员应当将业务逻辑代码写在这里 //当用户每访问该servlet时，都会被调用 //req:用于获得客户端（浏览器）的信息 //res:用于向客户端（浏览器）返回信息 public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException &#123; //为了解其执行方式，让它在控制台打印 System.out.println(\"service it\"); //从res中得到PrintWrite PrintWriter pw=res.getWriter(); pw.println(\"hello world\"); &#125; public String getServletInfo() &#123; // TODO: Add your code here return \"\"; &#125; //销毁servlet实例（释放内存） //1.reload改servlet //2.关闭servlet //3.关机 public void destroy() &#123; // TODO: Add your code here System.out.println(\"destroy\"); &#125; new APlayer({ element: document.getElementById(\"aplayer5\"), narrow: false, autoplay: true, showlrc: 0, music: { title: \"最后的倾诉\", author: \"韩磊\", url: \"http://ozjh9fb7b.bkt.clouddn.com/%E9%9F%A9%E7%A3%8A%20-%20%E6%9C%80%E5%90%8E%E7%9A%84%E5%80%BE%E8%AF%89.mp3\", pic: \"\", } }); 文件部署1234567891011121314 &lt;servlet&gt; &lt;!-- 给你的servlet取名，任意的--&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;!--指明servlet的路径，（包名+类名）--&gt; &lt;servlet-class&gt;com.zy.Hello&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;!-- 给你的servlet取名，任意的，与上面的名字对应--&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;!--这是在浏览器中输入的访问该servlet的url,任意的--&gt; &lt;url-pattern&gt;/zy&lt;/url-pattern&gt;&lt;/web-app&gt; 完成上述两步后，然后启动tomcat，输入对应的URL可实现相关servlet的访问","categories":[{"name":"职场进阶","slug":"职场进阶","permalink":"http://yoursite.com/categories/职场进阶/"}],"tags":[{"name":"CGI","slug":"CGI","permalink":"http://yoursite.com/tags/CGI/"},{"name":"Servlet","slug":"Servlet","permalink":"http://yoursite.com/tags/Servlet/"}]},{"title":"Java web整合开发一","slug":"Java Web整合开发1","date":"2017-11-20T12:30:33.000Z","updated":"2017-12-26T14:09:49.196Z","comments":true,"path":"2017/11/20/Java Web整合开发1/","link":"","permalink":"http://yoursite.com/2017/11/20/Java Web整合开发1/","excerpt":"静态页面&#160; &#160; 单纯的用Html、CSS（负责对Html整体管理，可以内嵌到Html语言，也可以单独编写成文件，在Html语言中外部引用）语言编写的页面，其特点就是“死的”，无法与外部进行交互，就像搭建的博客本身，呈现给读者的只是一个单纯的网页，这个网页除了开发者从后台操作之外，并不会“动”","text":"静态页面&#160; &#160; 单纯的用Html、CSS（负责对Html整体管理，可以内嵌到Html语言，也可以单独编写成文件，在Html语言中外部引用）语言编写的页面，其特点就是“死的”，无法与外部进行交互，就像搭建的博客本身，呈现给读者的只是一个单纯的网页，这个网页除了开发者从后台操作之外，并不会“动”&#160;&#160;为了让网页“活起来”，CGI（Common Gateway interface，公共网关接口）诞生了，特点是运行在服务器端，根据不同客户端请求输出相应的HTML页面，然后Web服务器再把这个静态页面返回给浏览器作为客户端的响应。 ***********服务器端********** * * * * 1.输出URL地址 * 2.向服务器发送浏览请求 3.请求运行 5.输出生成 ********************** ************************* 某个CGI程序 HTML语言 * * * 用户 客户端 * * * 浏览器 * * * * * ********************** ************************* * * * 7.显示HTML * 6.返回HTML页面作出响应 CGI程序生成所需的HTML文件 * * 4.读取数据库或者文件 * * 数据库 CGI的操作过程 类比java程序，CGI程序的语言主要有两种Perl和shell脚本(java，c，c++均可)，CGI可以访问存储数据库中的数据或者其他系统中的文件，实现动态生成效果。不足之处： 每个请求均需要启动一个可执行的CGI程序，如果请求频繁。。。 为了解决这个问题，改进的CGI诞生了，即所谓的Java Servert，本质上是程序（在Java中程序是以类为单位的，没毛病吧？，这其实也是servert比CGI的高明之处，CGI有点像面向过程，而Servlet面向对象，可供多个对象同时调用），用于处理来自浏览器的指令（网址），并向浏览器输出html代码，该程序提供了多种类及其方法却没有main方法，所以不能主动执行，由web服务器如（Tomcat）调用Servlet的中的方法来实现。 new APlayer({ element: document.getElementById(\"aplayer3\"), narrow: false, autoplay: true, showlrc: 0, music: { title: \"白龙马\", author: \"樊竹青\", url: \"http://ozjh9fb7b.bkt.clouddn.com/%E6%A8%8A%E7%AB%B9%E9%9D%92%20-%20%E7%99%BD%E9%BE%99%E9%A9%AC.mp3\", pic: \"\", } }); &#160;&#160;&#160;&#160;Servert的模板：JSP（Java Server Pages）*实现普通静态html和动态html混合编码，其是Servlet API的扩展，把它当成servlet的一种 JSP基本原理 翻译：编写好的JSP（.jsp文件）文件首先会被Web容器中JSP（也是Servlet引擎）引擎转换成Java源代码。 编译：Java代码通过Jvm(Java虚拟机)编程成可执行的字节码（二进制形式） 请求：当Web服务器（“容器”）接受了客户端的请求后，执行上述的字节码，生成相应的页面反馈给浏览器显示 Java Web开发环境：开发者工具包JDK，集成开发环境IDE（集编写、编译、部署和调试程序的“一条龙服务”），Java Web服务器（所谓的“容器”），web应用程序都需要部署到容器中运行","categories":[{"name":"职场进阶","slug":"职场进阶","permalink":"http://yoursite.com/categories/职场进阶/"}],"tags":[{"name":"CGI","slug":"CGI","permalink":"http://yoursite.com/tags/CGI/"},{"name":"Servlet","slug":"Servlet","permalink":"http://yoursite.com/tags/Servlet/"}]},{"title":"初步看书后的困扰","slug":"当下的问题","date":"2017-11-19T07:27:33.000Z","updated":"2017-12-26T14:07:37.561Z","comments":true,"path":"2017/11/19/当下的问题/","link":"","permalink":"http://yoursite.com/2017/11/19/当下的问题/","excerpt":"需求&#160; &#160; &#160; &#160;根据单位那边同事的建议，工作这要涉及到的知识有java，javascript,spring框架，extjs框架，oricle数据库，Sql语句，工作的内容包括了从网站搭建到后台数据库的交互。","text":"需求&#160; &#160; &#160; &#160;根据单位那边同事的建议，工作这要涉及到的知识有java，javascript,spring框架，extjs框架，oricle数据库，Sql语句，工作的内容包括了从网站搭建到后台数据库的交互。 计划和进度&#160; &#160; &#160; &#160;毕竟是半路出家，自己要做好打算，而且根据那边的意思可能要涉及到人工智能、无监督学习方面的知识等等，这不正是自己希望的嘛 先把网铺开&#160; &#160; &#160; &#160;七年间与计算机方面相关的也就是编程这一小块了，现在要做的就是把这个领域的知识网铺开，先有语言基础开始，慢慢往外拓宽，目前的状态时，看完了java语言编程，能编写简单的小程序，对着书能够写程序实现对数据库的简单访问和数去读取；前端方面，学习了html、css和javascript，按照知乎上大牛们的建议，学习这些知识后，基本上就可以弄一些项目练练手了，目前手上的书籍中的项目感觉都比较冗大，都是真实的企业级项目，感觉好吃力。 new APlayer({ element: document.getElementById(\"aplayer7\"), narrow: false, autoplay: true, showlrc: 0, music: { title: \"渔舟唱晚\", author: \"浦琦璋\", url: \"http://ozjh9fb7b.bkt.clouddn.com/%E6%B5%A6%E7%90%A6%E7%92%8B%20-%20%E6%B8%94%E8%88%9F%E5%94%B1%E6%99%9A%20%28cut%E7%89%88%29.mp3\", pic: \"\", } }); 困惑和不解&#160; &#160; &#160; &#160;先把现有的问题抛在这面，以后来逐一解释：&#160; &#160; &#160; &#160;1.就拿之前的酒店企业进销存管理系统来说，必然要涉及到用户、商品信息的读取吧，实现这些方法的class可以用java写，难以理解的是，在class对象化的过程中必然要去读取数据库既有的商品、用户信息，在成功连接数据库后，数据库中各种信息是以何种方式，分门别类的传向相关的类实现数据的调用的(感觉问题都没列清楚啊)&#160; &#160; &#160; &#160;2.java面向对象编程的一个核心技术是API的应用，说白了，java自身帮我们已经写了大量的函数，在开发过程中，程序猿要尽量去调用现有的API（即方法，C中称为函数），如何快速的找到自己所需的API。（这跟开发工具的使用有关吧，单位用的intellij idea，捣鼓去吧）&#160; &#160; &#160; &#160;3.前端方面，html和css较为容易，javascript也比较好掌握，但是如何把它们结合起来写一个像样的网站出来，这需要练习，初步想法是选几个网站，利用上述的知识把它们的网站复现出来&#160; &#160; &#160; &#160;4.框架，就目前的看到的相关知识，还未涉及到，感觉一头雾水啊","categories":[{"name":"职场进阶","slug":"职场进阶","permalink":"http://yoursite.com/categories/职场进阶/"}],"tags":[{"name":"前端开发","slug":"前端开发","permalink":"http://yoursite.com/tags/前端开发/"},{"name":"框架","slug":"框架","permalink":"http://yoursite.com/tags/框架/"}]}]}